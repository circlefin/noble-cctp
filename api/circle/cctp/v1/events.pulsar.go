// Code generated by protoc-gen-go-pulsar. DO NOT EDIT.
package cctpv1

import (
	fmt "fmt"
	runtime "github.com/cosmos/cosmos-proto/runtime"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoiface "google.golang.org/protobuf/runtime/protoiface"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	io "io"
	reflect "reflect"
	sync "sync"
)

var (
	md_AttesterEnabled          protoreflect.MessageDescriptor
	fd_AttesterEnabled_attester protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_AttesterEnabled = File_circle_cctp_v1_events_proto.Messages().ByName("AttesterEnabled")
	fd_AttesterEnabled_attester = md_AttesterEnabled.Fields().ByName("attester")
}

var _ protoreflect.Message = (*fastReflection_AttesterEnabled)(nil)

type fastReflection_AttesterEnabled AttesterEnabled

func (x *AttesterEnabled) ProtoReflect() protoreflect.Message {
	return (*fastReflection_AttesterEnabled)(x)
}

func (x *AttesterEnabled) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_AttesterEnabled_messageType fastReflection_AttesterEnabled_messageType
var _ protoreflect.MessageType = fastReflection_AttesterEnabled_messageType{}

type fastReflection_AttesterEnabled_messageType struct{}

func (x fastReflection_AttesterEnabled_messageType) Zero() protoreflect.Message {
	return (*fastReflection_AttesterEnabled)(nil)
}
func (x fastReflection_AttesterEnabled_messageType) New() protoreflect.Message {
	return new(fastReflection_AttesterEnabled)
}
func (x fastReflection_AttesterEnabled_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_AttesterEnabled
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_AttesterEnabled) Descriptor() protoreflect.MessageDescriptor {
	return md_AttesterEnabled
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_AttesterEnabled) Type() protoreflect.MessageType {
	return _fastReflection_AttesterEnabled_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_AttesterEnabled) New() protoreflect.Message {
	return new(fastReflection_AttesterEnabled)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_AttesterEnabled) Interface() protoreflect.ProtoMessage {
	return (*AttesterEnabled)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_AttesterEnabled) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Attester != "" {
		value := protoreflect.ValueOfString(x.Attester)
		if !f(fd_AttesterEnabled_attester, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_AttesterEnabled) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterEnabled.attester":
		return x.Attester != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterEnabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterEnabled does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterEnabled) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterEnabled.attester":
		x.Attester = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterEnabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterEnabled does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_AttesterEnabled) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.AttesterEnabled.attester":
		value := x.Attester
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterEnabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterEnabled does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterEnabled) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterEnabled.attester":
		x.Attester = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterEnabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterEnabled does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterEnabled) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterEnabled.attester":
		panic(fmt.Errorf("field attester of message circle.cctp.v1.AttesterEnabled is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterEnabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterEnabled does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_AttesterEnabled) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterEnabled.attester":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterEnabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterEnabled does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_AttesterEnabled) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.AttesterEnabled", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_AttesterEnabled) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterEnabled) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_AttesterEnabled) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_AttesterEnabled) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*AttesterEnabled)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Attester)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*AttesterEnabled)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Attester) > 0 {
			i -= len(x.Attester)
			copy(dAtA[i:], x.Attester)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Attester)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*AttesterEnabled)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AttesterEnabled: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AttesterEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Attester = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_AttesterDisabled          protoreflect.MessageDescriptor
	fd_AttesterDisabled_attester protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_AttesterDisabled = File_circle_cctp_v1_events_proto.Messages().ByName("AttesterDisabled")
	fd_AttesterDisabled_attester = md_AttesterDisabled.Fields().ByName("attester")
}

var _ protoreflect.Message = (*fastReflection_AttesterDisabled)(nil)

type fastReflection_AttesterDisabled AttesterDisabled

func (x *AttesterDisabled) ProtoReflect() protoreflect.Message {
	return (*fastReflection_AttesterDisabled)(x)
}

func (x *AttesterDisabled) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_AttesterDisabled_messageType fastReflection_AttesterDisabled_messageType
var _ protoreflect.MessageType = fastReflection_AttesterDisabled_messageType{}

type fastReflection_AttesterDisabled_messageType struct{}

func (x fastReflection_AttesterDisabled_messageType) Zero() protoreflect.Message {
	return (*fastReflection_AttesterDisabled)(nil)
}
func (x fastReflection_AttesterDisabled_messageType) New() protoreflect.Message {
	return new(fastReflection_AttesterDisabled)
}
func (x fastReflection_AttesterDisabled_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_AttesterDisabled
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_AttesterDisabled) Descriptor() protoreflect.MessageDescriptor {
	return md_AttesterDisabled
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_AttesterDisabled) Type() protoreflect.MessageType {
	return _fastReflection_AttesterDisabled_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_AttesterDisabled) New() protoreflect.Message {
	return new(fastReflection_AttesterDisabled)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_AttesterDisabled) Interface() protoreflect.ProtoMessage {
	return (*AttesterDisabled)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_AttesterDisabled) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Attester != "" {
		value := protoreflect.ValueOfString(x.Attester)
		if !f(fd_AttesterDisabled_attester, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_AttesterDisabled) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterDisabled.attester":
		return x.Attester != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterDisabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterDisabled does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterDisabled) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterDisabled.attester":
		x.Attester = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterDisabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterDisabled does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_AttesterDisabled) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.AttesterDisabled.attester":
		value := x.Attester
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterDisabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterDisabled does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterDisabled) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterDisabled.attester":
		x.Attester = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterDisabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterDisabled does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterDisabled) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterDisabled.attester":
		panic(fmt.Errorf("field attester of message circle.cctp.v1.AttesterDisabled is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterDisabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterDisabled does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_AttesterDisabled) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterDisabled.attester":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterDisabled"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterDisabled does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_AttesterDisabled) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.AttesterDisabled", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_AttesterDisabled) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterDisabled) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_AttesterDisabled) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_AttesterDisabled) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*AttesterDisabled)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Attester)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*AttesterDisabled)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Attester) > 0 {
			i -= len(x.Attester)
			copy(dAtA[i:], x.Attester)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Attester)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*AttesterDisabled)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AttesterDisabled: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AttesterDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Attester = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_SignatureThresholdUpdated                         protoreflect.MessageDescriptor
	fd_SignatureThresholdUpdated_old_signature_threshold protoreflect.FieldDescriptor
	fd_SignatureThresholdUpdated_new_signature_threshold protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_SignatureThresholdUpdated = File_circle_cctp_v1_events_proto.Messages().ByName("SignatureThresholdUpdated")
	fd_SignatureThresholdUpdated_old_signature_threshold = md_SignatureThresholdUpdated.Fields().ByName("old_signature_threshold")
	fd_SignatureThresholdUpdated_new_signature_threshold = md_SignatureThresholdUpdated.Fields().ByName("new_signature_threshold")
}

var _ protoreflect.Message = (*fastReflection_SignatureThresholdUpdated)(nil)

type fastReflection_SignatureThresholdUpdated SignatureThresholdUpdated

func (x *SignatureThresholdUpdated) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SignatureThresholdUpdated)(x)
}

func (x *SignatureThresholdUpdated) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SignatureThresholdUpdated_messageType fastReflection_SignatureThresholdUpdated_messageType
var _ protoreflect.MessageType = fastReflection_SignatureThresholdUpdated_messageType{}

type fastReflection_SignatureThresholdUpdated_messageType struct{}

func (x fastReflection_SignatureThresholdUpdated_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SignatureThresholdUpdated)(nil)
}
func (x fastReflection_SignatureThresholdUpdated_messageType) New() protoreflect.Message {
	return new(fastReflection_SignatureThresholdUpdated)
}
func (x fastReflection_SignatureThresholdUpdated_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SignatureThresholdUpdated
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SignatureThresholdUpdated) Descriptor() protoreflect.MessageDescriptor {
	return md_SignatureThresholdUpdated
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SignatureThresholdUpdated) Type() protoreflect.MessageType {
	return _fastReflection_SignatureThresholdUpdated_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SignatureThresholdUpdated) New() protoreflect.Message {
	return new(fastReflection_SignatureThresholdUpdated)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SignatureThresholdUpdated) Interface() protoreflect.ProtoMessage {
	return (*SignatureThresholdUpdated)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SignatureThresholdUpdated) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.OldSignatureThreshold != uint64(0) {
		value := protoreflect.ValueOfUint64(x.OldSignatureThreshold)
		if !f(fd_SignatureThresholdUpdated_old_signature_threshold, value) {
			return
		}
	}
	if x.NewSignatureThreshold != uint64(0) {
		value := protoreflect.ValueOfUint64(x.NewSignatureThreshold)
		if !f(fd_SignatureThresholdUpdated_new_signature_threshold, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SignatureThresholdUpdated) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.SignatureThresholdUpdated.old_signature_threshold":
		return x.OldSignatureThreshold != uint64(0)
	case "circle.cctp.v1.SignatureThresholdUpdated.new_signature_threshold":
		return x.NewSignatureThreshold != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SignatureThresholdUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SignatureThresholdUpdated does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SignatureThresholdUpdated) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.SignatureThresholdUpdated.old_signature_threshold":
		x.OldSignatureThreshold = uint64(0)
	case "circle.cctp.v1.SignatureThresholdUpdated.new_signature_threshold":
		x.NewSignatureThreshold = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SignatureThresholdUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SignatureThresholdUpdated does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SignatureThresholdUpdated) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.SignatureThresholdUpdated.old_signature_threshold":
		value := x.OldSignatureThreshold
		return protoreflect.ValueOfUint64(value)
	case "circle.cctp.v1.SignatureThresholdUpdated.new_signature_threshold":
		value := x.NewSignatureThreshold
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SignatureThresholdUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SignatureThresholdUpdated does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SignatureThresholdUpdated) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.SignatureThresholdUpdated.old_signature_threshold":
		x.OldSignatureThreshold = value.Uint()
	case "circle.cctp.v1.SignatureThresholdUpdated.new_signature_threshold":
		x.NewSignatureThreshold = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SignatureThresholdUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SignatureThresholdUpdated does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SignatureThresholdUpdated) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.SignatureThresholdUpdated.old_signature_threshold":
		panic(fmt.Errorf("field old_signature_threshold of message circle.cctp.v1.SignatureThresholdUpdated is not mutable"))
	case "circle.cctp.v1.SignatureThresholdUpdated.new_signature_threshold":
		panic(fmt.Errorf("field new_signature_threshold of message circle.cctp.v1.SignatureThresholdUpdated is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SignatureThresholdUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SignatureThresholdUpdated does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SignatureThresholdUpdated) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.SignatureThresholdUpdated.old_signature_threshold":
		return protoreflect.ValueOfUint64(uint64(0))
	case "circle.cctp.v1.SignatureThresholdUpdated.new_signature_threshold":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SignatureThresholdUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SignatureThresholdUpdated does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SignatureThresholdUpdated) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.SignatureThresholdUpdated", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SignatureThresholdUpdated) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SignatureThresholdUpdated) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SignatureThresholdUpdated) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SignatureThresholdUpdated) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SignatureThresholdUpdated)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.OldSignatureThreshold != 0 {
			n += 1 + runtime.Sov(uint64(x.OldSignatureThreshold))
		}
		if x.NewSignatureThreshold != 0 {
			n += 1 + runtime.Sov(uint64(x.NewSignatureThreshold))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SignatureThresholdUpdated)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.NewSignatureThreshold != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NewSignatureThreshold))
			i--
			dAtA[i] = 0x10
		}
		if x.OldSignatureThreshold != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.OldSignatureThreshold))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SignatureThresholdUpdated)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SignatureThresholdUpdated: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SignatureThresholdUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field OldSignatureThreshold", wireType)
				}
				x.OldSignatureThreshold = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.OldSignatureThreshold |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewSignatureThreshold", wireType)
				}
				x.NewSignatureThreshold = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NewSignatureThreshold |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_OwnerUpdated                protoreflect.MessageDescriptor
	fd_OwnerUpdated_previous_owner protoreflect.FieldDescriptor
	fd_OwnerUpdated_new_owner      protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_OwnerUpdated = File_circle_cctp_v1_events_proto.Messages().ByName("OwnerUpdated")
	fd_OwnerUpdated_previous_owner = md_OwnerUpdated.Fields().ByName("previous_owner")
	fd_OwnerUpdated_new_owner = md_OwnerUpdated.Fields().ByName("new_owner")
}

var _ protoreflect.Message = (*fastReflection_OwnerUpdated)(nil)

type fastReflection_OwnerUpdated OwnerUpdated

func (x *OwnerUpdated) ProtoReflect() protoreflect.Message {
	return (*fastReflection_OwnerUpdated)(x)
}

func (x *OwnerUpdated) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_OwnerUpdated_messageType fastReflection_OwnerUpdated_messageType
var _ protoreflect.MessageType = fastReflection_OwnerUpdated_messageType{}

type fastReflection_OwnerUpdated_messageType struct{}

func (x fastReflection_OwnerUpdated_messageType) Zero() protoreflect.Message {
	return (*fastReflection_OwnerUpdated)(nil)
}
func (x fastReflection_OwnerUpdated_messageType) New() protoreflect.Message {
	return new(fastReflection_OwnerUpdated)
}
func (x fastReflection_OwnerUpdated_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_OwnerUpdated
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_OwnerUpdated) Descriptor() protoreflect.MessageDescriptor {
	return md_OwnerUpdated
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_OwnerUpdated) Type() protoreflect.MessageType {
	return _fastReflection_OwnerUpdated_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_OwnerUpdated) New() protoreflect.Message {
	return new(fastReflection_OwnerUpdated)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_OwnerUpdated) Interface() protoreflect.ProtoMessage {
	return (*OwnerUpdated)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_OwnerUpdated) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PreviousOwner != "" {
		value := protoreflect.ValueOfString(x.PreviousOwner)
		if !f(fd_OwnerUpdated_previous_owner, value) {
			return
		}
	}
	if x.NewOwner != "" {
		value := protoreflect.ValueOfString(x.NewOwner)
		if !f(fd_OwnerUpdated_new_owner, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_OwnerUpdated) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnerUpdated.previous_owner":
		return x.PreviousOwner != ""
	case "circle.cctp.v1.OwnerUpdated.new_owner":
		return x.NewOwner != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnerUpdated does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OwnerUpdated) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnerUpdated.previous_owner":
		x.PreviousOwner = ""
	case "circle.cctp.v1.OwnerUpdated.new_owner":
		x.NewOwner = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnerUpdated does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_OwnerUpdated) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.OwnerUpdated.previous_owner":
		value := x.PreviousOwner
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.OwnerUpdated.new_owner":
		value := x.NewOwner
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnerUpdated does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OwnerUpdated) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnerUpdated.previous_owner":
		x.PreviousOwner = value.Interface().(string)
	case "circle.cctp.v1.OwnerUpdated.new_owner":
		x.NewOwner = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnerUpdated does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OwnerUpdated) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnerUpdated.previous_owner":
		panic(fmt.Errorf("field previous_owner of message circle.cctp.v1.OwnerUpdated is not mutable"))
	case "circle.cctp.v1.OwnerUpdated.new_owner":
		panic(fmt.Errorf("field new_owner of message circle.cctp.v1.OwnerUpdated is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnerUpdated does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_OwnerUpdated) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnerUpdated.previous_owner":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.OwnerUpdated.new_owner":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnerUpdated does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_OwnerUpdated) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.OwnerUpdated", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_OwnerUpdated) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OwnerUpdated) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_OwnerUpdated) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_OwnerUpdated) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*OwnerUpdated)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PreviousOwner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NewOwner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*OwnerUpdated)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.NewOwner) > 0 {
			i -= len(x.NewOwner)
			copy(dAtA[i:], x.NewOwner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NewOwner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PreviousOwner) > 0 {
			i -= len(x.PreviousOwner)
			copy(dAtA[i:], x.PreviousOwner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PreviousOwner)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*OwnerUpdated)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: OwnerUpdated: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: OwnerUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PreviousOwner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PreviousOwner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewOwner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NewOwner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_OwnershipTransferStarted                protoreflect.MessageDescriptor
	fd_OwnershipTransferStarted_previous_owner protoreflect.FieldDescriptor
	fd_OwnershipTransferStarted_new_owner      protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_OwnershipTransferStarted = File_circle_cctp_v1_events_proto.Messages().ByName("OwnershipTransferStarted")
	fd_OwnershipTransferStarted_previous_owner = md_OwnershipTransferStarted.Fields().ByName("previous_owner")
	fd_OwnershipTransferStarted_new_owner = md_OwnershipTransferStarted.Fields().ByName("new_owner")
}

var _ protoreflect.Message = (*fastReflection_OwnershipTransferStarted)(nil)

type fastReflection_OwnershipTransferStarted OwnershipTransferStarted

func (x *OwnershipTransferStarted) ProtoReflect() protoreflect.Message {
	return (*fastReflection_OwnershipTransferStarted)(x)
}

func (x *OwnershipTransferStarted) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_OwnershipTransferStarted_messageType fastReflection_OwnershipTransferStarted_messageType
var _ protoreflect.MessageType = fastReflection_OwnershipTransferStarted_messageType{}

type fastReflection_OwnershipTransferStarted_messageType struct{}

func (x fastReflection_OwnershipTransferStarted_messageType) Zero() protoreflect.Message {
	return (*fastReflection_OwnershipTransferStarted)(nil)
}
func (x fastReflection_OwnershipTransferStarted_messageType) New() protoreflect.Message {
	return new(fastReflection_OwnershipTransferStarted)
}
func (x fastReflection_OwnershipTransferStarted_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_OwnershipTransferStarted
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_OwnershipTransferStarted) Descriptor() protoreflect.MessageDescriptor {
	return md_OwnershipTransferStarted
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_OwnershipTransferStarted) Type() protoreflect.MessageType {
	return _fastReflection_OwnershipTransferStarted_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_OwnershipTransferStarted) New() protoreflect.Message {
	return new(fastReflection_OwnershipTransferStarted)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_OwnershipTransferStarted) Interface() protoreflect.ProtoMessage {
	return (*OwnershipTransferStarted)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_OwnershipTransferStarted) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PreviousOwner != "" {
		value := protoreflect.ValueOfString(x.PreviousOwner)
		if !f(fd_OwnershipTransferStarted_previous_owner, value) {
			return
		}
	}
	if x.NewOwner != "" {
		value := protoreflect.ValueOfString(x.NewOwner)
		if !f(fd_OwnershipTransferStarted_new_owner, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_OwnershipTransferStarted) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnershipTransferStarted.previous_owner":
		return x.PreviousOwner != ""
	case "circle.cctp.v1.OwnershipTransferStarted.new_owner":
		return x.NewOwner != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnershipTransferStarted"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnershipTransferStarted does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OwnershipTransferStarted) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnershipTransferStarted.previous_owner":
		x.PreviousOwner = ""
	case "circle.cctp.v1.OwnershipTransferStarted.new_owner":
		x.NewOwner = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnershipTransferStarted"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnershipTransferStarted does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_OwnershipTransferStarted) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.OwnershipTransferStarted.previous_owner":
		value := x.PreviousOwner
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.OwnershipTransferStarted.new_owner":
		value := x.NewOwner
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnershipTransferStarted"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnershipTransferStarted does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OwnershipTransferStarted) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnershipTransferStarted.previous_owner":
		x.PreviousOwner = value.Interface().(string)
	case "circle.cctp.v1.OwnershipTransferStarted.new_owner":
		x.NewOwner = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnershipTransferStarted"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnershipTransferStarted does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OwnershipTransferStarted) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnershipTransferStarted.previous_owner":
		panic(fmt.Errorf("field previous_owner of message circle.cctp.v1.OwnershipTransferStarted is not mutable"))
	case "circle.cctp.v1.OwnershipTransferStarted.new_owner":
		panic(fmt.Errorf("field new_owner of message circle.cctp.v1.OwnershipTransferStarted is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnershipTransferStarted"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnershipTransferStarted does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_OwnershipTransferStarted) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.OwnershipTransferStarted.previous_owner":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.OwnershipTransferStarted.new_owner":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.OwnershipTransferStarted"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.OwnershipTransferStarted does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_OwnershipTransferStarted) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.OwnershipTransferStarted", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_OwnershipTransferStarted) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_OwnershipTransferStarted) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_OwnershipTransferStarted) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_OwnershipTransferStarted) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*OwnershipTransferStarted)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PreviousOwner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NewOwner)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*OwnershipTransferStarted)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.NewOwner) > 0 {
			i -= len(x.NewOwner)
			copy(dAtA[i:], x.NewOwner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NewOwner)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PreviousOwner) > 0 {
			i -= len(x.PreviousOwner)
			copy(dAtA[i:], x.PreviousOwner)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PreviousOwner)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*OwnershipTransferStarted)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: OwnershipTransferStarted: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: OwnershipTransferStarted: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PreviousOwner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PreviousOwner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewOwner", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NewOwner = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_PauserUpdated                 protoreflect.MessageDescriptor
	fd_PauserUpdated_previous_pauser protoreflect.FieldDescriptor
	fd_PauserUpdated_new_pauser      protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_PauserUpdated = File_circle_cctp_v1_events_proto.Messages().ByName("PauserUpdated")
	fd_PauserUpdated_previous_pauser = md_PauserUpdated.Fields().ByName("previous_pauser")
	fd_PauserUpdated_new_pauser = md_PauserUpdated.Fields().ByName("new_pauser")
}

var _ protoreflect.Message = (*fastReflection_PauserUpdated)(nil)

type fastReflection_PauserUpdated PauserUpdated

func (x *PauserUpdated) ProtoReflect() protoreflect.Message {
	return (*fastReflection_PauserUpdated)(x)
}

func (x *PauserUpdated) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_PauserUpdated_messageType fastReflection_PauserUpdated_messageType
var _ protoreflect.MessageType = fastReflection_PauserUpdated_messageType{}

type fastReflection_PauserUpdated_messageType struct{}

func (x fastReflection_PauserUpdated_messageType) Zero() protoreflect.Message {
	return (*fastReflection_PauserUpdated)(nil)
}
func (x fastReflection_PauserUpdated_messageType) New() protoreflect.Message {
	return new(fastReflection_PauserUpdated)
}
func (x fastReflection_PauserUpdated_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_PauserUpdated
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_PauserUpdated) Descriptor() protoreflect.MessageDescriptor {
	return md_PauserUpdated
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_PauserUpdated) Type() protoreflect.MessageType {
	return _fastReflection_PauserUpdated_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_PauserUpdated) New() protoreflect.Message {
	return new(fastReflection_PauserUpdated)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_PauserUpdated) Interface() protoreflect.ProtoMessage {
	return (*PauserUpdated)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_PauserUpdated) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PreviousPauser != "" {
		value := protoreflect.ValueOfString(x.PreviousPauser)
		if !f(fd_PauserUpdated_previous_pauser, value) {
			return
		}
	}
	if x.NewPauser != "" {
		value := protoreflect.ValueOfString(x.NewPauser)
		if !f(fd_PauserUpdated_new_pauser, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_PauserUpdated) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.PauserUpdated.previous_pauser":
		return x.PreviousPauser != ""
	case "circle.cctp.v1.PauserUpdated.new_pauser":
		return x.NewPauser != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.PauserUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.PauserUpdated does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PauserUpdated) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.PauserUpdated.previous_pauser":
		x.PreviousPauser = ""
	case "circle.cctp.v1.PauserUpdated.new_pauser":
		x.NewPauser = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.PauserUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.PauserUpdated does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_PauserUpdated) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.PauserUpdated.previous_pauser":
		value := x.PreviousPauser
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.PauserUpdated.new_pauser":
		value := x.NewPauser
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.PauserUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.PauserUpdated does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PauserUpdated) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.PauserUpdated.previous_pauser":
		x.PreviousPauser = value.Interface().(string)
	case "circle.cctp.v1.PauserUpdated.new_pauser":
		x.NewPauser = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.PauserUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.PauserUpdated does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PauserUpdated) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.PauserUpdated.previous_pauser":
		panic(fmt.Errorf("field previous_pauser of message circle.cctp.v1.PauserUpdated is not mutable"))
	case "circle.cctp.v1.PauserUpdated.new_pauser":
		panic(fmt.Errorf("field new_pauser of message circle.cctp.v1.PauserUpdated is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.PauserUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.PauserUpdated does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_PauserUpdated) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.PauserUpdated.previous_pauser":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.PauserUpdated.new_pauser":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.PauserUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.PauserUpdated does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_PauserUpdated) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.PauserUpdated", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_PauserUpdated) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_PauserUpdated) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_PauserUpdated) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_PauserUpdated) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*PauserUpdated)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PreviousPauser)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NewPauser)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*PauserUpdated)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.NewPauser) > 0 {
			i -= len(x.NewPauser)
			copy(dAtA[i:], x.NewPauser)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NewPauser)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PreviousPauser) > 0 {
			i -= len(x.PreviousPauser)
			copy(dAtA[i:], x.PreviousPauser)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PreviousPauser)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*PauserUpdated)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PauserUpdated: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: PauserUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PreviousPauser", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PreviousPauser = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewPauser", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NewPauser = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_AttesterManagerUpdated                           protoreflect.MessageDescriptor
	fd_AttesterManagerUpdated_previous_attester_manager protoreflect.FieldDescriptor
	fd_AttesterManagerUpdated_new_attester_manager      protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_AttesterManagerUpdated = File_circle_cctp_v1_events_proto.Messages().ByName("AttesterManagerUpdated")
	fd_AttesterManagerUpdated_previous_attester_manager = md_AttesterManagerUpdated.Fields().ByName("previous_attester_manager")
	fd_AttesterManagerUpdated_new_attester_manager = md_AttesterManagerUpdated.Fields().ByName("new_attester_manager")
}

var _ protoreflect.Message = (*fastReflection_AttesterManagerUpdated)(nil)

type fastReflection_AttesterManagerUpdated AttesterManagerUpdated

func (x *AttesterManagerUpdated) ProtoReflect() protoreflect.Message {
	return (*fastReflection_AttesterManagerUpdated)(x)
}

func (x *AttesterManagerUpdated) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_AttesterManagerUpdated_messageType fastReflection_AttesterManagerUpdated_messageType
var _ protoreflect.MessageType = fastReflection_AttesterManagerUpdated_messageType{}

type fastReflection_AttesterManagerUpdated_messageType struct{}

func (x fastReflection_AttesterManagerUpdated_messageType) Zero() protoreflect.Message {
	return (*fastReflection_AttesterManagerUpdated)(nil)
}
func (x fastReflection_AttesterManagerUpdated_messageType) New() protoreflect.Message {
	return new(fastReflection_AttesterManagerUpdated)
}
func (x fastReflection_AttesterManagerUpdated_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_AttesterManagerUpdated
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_AttesterManagerUpdated) Descriptor() protoreflect.MessageDescriptor {
	return md_AttesterManagerUpdated
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_AttesterManagerUpdated) Type() protoreflect.MessageType {
	return _fastReflection_AttesterManagerUpdated_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_AttesterManagerUpdated) New() protoreflect.Message {
	return new(fastReflection_AttesterManagerUpdated)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_AttesterManagerUpdated) Interface() protoreflect.ProtoMessage {
	return (*AttesterManagerUpdated)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_AttesterManagerUpdated) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PreviousAttesterManager != "" {
		value := protoreflect.ValueOfString(x.PreviousAttesterManager)
		if !f(fd_AttesterManagerUpdated_previous_attester_manager, value) {
			return
		}
	}
	if x.NewAttesterManager != "" {
		value := protoreflect.ValueOfString(x.NewAttesterManager)
		if !f(fd_AttesterManagerUpdated_new_attester_manager, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_AttesterManagerUpdated) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterManagerUpdated.previous_attester_manager":
		return x.PreviousAttesterManager != ""
	case "circle.cctp.v1.AttesterManagerUpdated.new_attester_manager":
		return x.NewAttesterManager != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterManagerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterManagerUpdated does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterManagerUpdated) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterManagerUpdated.previous_attester_manager":
		x.PreviousAttesterManager = ""
	case "circle.cctp.v1.AttesterManagerUpdated.new_attester_manager":
		x.NewAttesterManager = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterManagerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterManagerUpdated does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_AttesterManagerUpdated) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.AttesterManagerUpdated.previous_attester_manager":
		value := x.PreviousAttesterManager
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.AttesterManagerUpdated.new_attester_manager":
		value := x.NewAttesterManager
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterManagerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterManagerUpdated does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterManagerUpdated) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterManagerUpdated.previous_attester_manager":
		x.PreviousAttesterManager = value.Interface().(string)
	case "circle.cctp.v1.AttesterManagerUpdated.new_attester_manager":
		x.NewAttesterManager = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterManagerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterManagerUpdated does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterManagerUpdated) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterManagerUpdated.previous_attester_manager":
		panic(fmt.Errorf("field previous_attester_manager of message circle.cctp.v1.AttesterManagerUpdated is not mutable"))
	case "circle.cctp.v1.AttesterManagerUpdated.new_attester_manager":
		panic(fmt.Errorf("field new_attester_manager of message circle.cctp.v1.AttesterManagerUpdated is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterManagerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterManagerUpdated does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_AttesterManagerUpdated) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.AttesterManagerUpdated.previous_attester_manager":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.AttesterManagerUpdated.new_attester_manager":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.AttesterManagerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.AttesterManagerUpdated does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_AttesterManagerUpdated) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.AttesterManagerUpdated", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_AttesterManagerUpdated) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_AttesterManagerUpdated) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_AttesterManagerUpdated) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_AttesterManagerUpdated) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*AttesterManagerUpdated)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PreviousAttesterManager)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NewAttesterManager)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*AttesterManagerUpdated)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.NewAttesterManager) > 0 {
			i -= len(x.NewAttesterManager)
			copy(dAtA[i:], x.NewAttesterManager)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NewAttesterManager)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PreviousAttesterManager) > 0 {
			i -= len(x.PreviousAttesterManager)
			copy(dAtA[i:], x.PreviousAttesterManager)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PreviousAttesterManager)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*AttesterManagerUpdated)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AttesterManagerUpdated: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: AttesterManagerUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PreviousAttesterManager", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PreviousAttesterManager = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewAttesterManager", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NewAttesterManager = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_TokenControllerUpdated                           protoreflect.MessageDescriptor
	fd_TokenControllerUpdated_previous_token_controller protoreflect.FieldDescriptor
	fd_TokenControllerUpdated_new_token_controller      protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_TokenControllerUpdated = File_circle_cctp_v1_events_proto.Messages().ByName("TokenControllerUpdated")
	fd_TokenControllerUpdated_previous_token_controller = md_TokenControllerUpdated.Fields().ByName("previous_token_controller")
	fd_TokenControllerUpdated_new_token_controller = md_TokenControllerUpdated.Fields().ByName("new_token_controller")
}

var _ protoreflect.Message = (*fastReflection_TokenControllerUpdated)(nil)

type fastReflection_TokenControllerUpdated TokenControllerUpdated

func (x *TokenControllerUpdated) ProtoReflect() protoreflect.Message {
	return (*fastReflection_TokenControllerUpdated)(x)
}

func (x *TokenControllerUpdated) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_TokenControllerUpdated_messageType fastReflection_TokenControllerUpdated_messageType
var _ protoreflect.MessageType = fastReflection_TokenControllerUpdated_messageType{}

type fastReflection_TokenControllerUpdated_messageType struct{}

func (x fastReflection_TokenControllerUpdated_messageType) Zero() protoreflect.Message {
	return (*fastReflection_TokenControllerUpdated)(nil)
}
func (x fastReflection_TokenControllerUpdated_messageType) New() protoreflect.Message {
	return new(fastReflection_TokenControllerUpdated)
}
func (x fastReflection_TokenControllerUpdated_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_TokenControllerUpdated
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_TokenControllerUpdated) Descriptor() protoreflect.MessageDescriptor {
	return md_TokenControllerUpdated
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_TokenControllerUpdated) Type() protoreflect.MessageType {
	return _fastReflection_TokenControllerUpdated_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_TokenControllerUpdated) New() protoreflect.Message {
	return new(fastReflection_TokenControllerUpdated)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_TokenControllerUpdated) Interface() protoreflect.ProtoMessage {
	return (*TokenControllerUpdated)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_TokenControllerUpdated) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.PreviousTokenController != "" {
		value := protoreflect.ValueOfString(x.PreviousTokenController)
		if !f(fd_TokenControllerUpdated_previous_token_controller, value) {
			return
		}
	}
	if x.NewTokenController != "" {
		value := protoreflect.ValueOfString(x.NewTokenController)
		if !f(fd_TokenControllerUpdated_new_token_controller, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_TokenControllerUpdated) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenControllerUpdated.previous_token_controller":
		return x.PreviousTokenController != ""
	case "circle.cctp.v1.TokenControllerUpdated.new_token_controller":
		return x.NewTokenController != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenControllerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenControllerUpdated does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenControllerUpdated) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenControllerUpdated.previous_token_controller":
		x.PreviousTokenController = ""
	case "circle.cctp.v1.TokenControllerUpdated.new_token_controller":
		x.NewTokenController = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenControllerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenControllerUpdated does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_TokenControllerUpdated) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.TokenControllerUpdated.previous_token_controller":
		value := x.PreviousTokenController
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.TokenControllerUpdated.new_token_controller":
		value := x.NewTokenController
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenControllerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenControllerUpdated does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenControllerUpdated) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenControllerUpdated.previous_token_controller":
		x.PreviousTokenController = value.Interface().(string)
	case "circle.cctp.v1.TokenControllerUpdated.new_token_controller":
		x.NewTokenController = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenControllerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenControllerUpdated does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenControllerUpdated) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenControllerUpdated.previous_token_controller":
		panic(fmt.Errorf("field previous_token_controller of message circle.cctp.v1.TokenControllerUpdated is not mutable"))
	case "circle.cctp.v1.TokenControllerUpdated.new_token_controller":
		panic(fmt.Errorf("field new_token_controller of message circle.cctp.v1.TokenControllerUpdated is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenControllerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenControllerUpdated does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_TokenControllerUpdated) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenControllerUpdated.previous_token_controller":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.TokenControllerUpdated.new_token_controller":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenControllerUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenControllerUpdated does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_TokenControllerUpdated) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.TokenControllerUpdated", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_TokenControllerUpdated) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenControllerUpdated) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_TokenControllerUpdated) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_TokenControllerUpdated) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*TokenControllerUpdated)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.PreviousTokenController)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.NewTokenController)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*TokenControllerUpdated)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.NewTokenController) > 0 {
			i -= len(x.NewTokenController)
			copy(dAtA[i:], x.NewTokenController)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.NewTokenController)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.PreviousTokenController) > 0 {
			i -= len(x.PreviousTokenController)
			copy(dAtA[i:], x.PreviousTokenController)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.PreviousTokenController)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*TokenControllerUpdated)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TokenControllerUpdated: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TokenControllerUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field PreviousTokenController", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.PreviousTokenController = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewTokenController", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.NewTokenController = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_BurningAndMintingPausedEvent protoreflect.MessageDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_BurningAndMintingPausedEvent = File_circle_cctp_v1_events_proto.Messages().ByName("BurningAndMintingPausedEvent")
}

var _ protoreflect.Message = (*fastReflection_BurningAndMintingPausedEvent)(nil)

type fastReflection_BurningAndMintingPausedEvent BurningAndMintingPausedEvent

func (x *BurningAndMintingPausedEvent) ProtoReflect() protoreflect.Message {
	return (*fastReflection_BurningAndMintingPausedEvent)(x)
}

func (x *BurningAndMintingPausedEvent) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_BurningAndMintingPausedEvent_messageType fastReflection_BurningAndMintingPausedEvent_messageType
var _ protoreflect.MessageType = fastReflection_BurningAndMintingPausedEvent_messageType{}

type fastReflection_BurningAndMintingPausedEvent_messageType struct{}

func (x fastReflection_BurningAndMintingPausedEvent_messageType) Zero() protoreflect.Message {
	return (*fastReflection_BurningAndMintingPausedEvent)(nil)
}
func (x fastReflection_BurningAndMintingPausedEvent_messageType) New() protoreflect.Message {
	return new(fastReflection_BurningAndMintingPausedEvent)
}
func (x fastReflection_BurningAndMintingPausedEvent_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_BurningAndMintingPausedEvent
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_BurningAndMintingPausedEvent) Descriptor() protoreflect.MessageDescriptor {
	return md_BurningAndMintingPausedEvent
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_BurningAndMintingPausedEvent) Type() protoreflect.MessageType {
	return _fastReflection_BurningAndMintingPausedEvent_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_BurningAndMintingPausedEvent) New() protoreflect.Message {
	return new(fastReflection_BurningAndMintingPausedEvent)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_BurningAndMintingPausedEvent) Interface() protoreflect.ProtoMessage {
	return (*BurningAndMintingPausedEvent)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_BurningAndMintingPausedEvent) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_BurningAndMintingPausedEvent) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BurningAndMintingPausedEvent) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_BurningAndMintingPausedEvent) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingPausedEvent does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BurningAndMintingPausedEvent) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BurningAndMintingPausedEvent) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_BurningAndMintingPausedEvent) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_BurningAndMintingPausedEvent) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.BurningAndMintingPausedEvent", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_BurningAndMintingPausedEvent) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BurningAndMintingPausedEvent) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_BurningAndMintingPausedEvent) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_BurningAndMintingPausedEvent) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*BurningAndMintingPausedEvent)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*BurningAndMintingPausedEvent)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*BurningAndMintingPausedEvent)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BurningAndMintingPausedEvent: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BurningAndMintingPausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_BurningAndMintingUnpausedEvent protoreflect.MessageDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_BurningAndMintingUnpausedEvent = File_circle_cctp_v1_events_proto.Messages().ByName("BurningAndMintingUnpausedEvent")
}

var _ protoreflect.Message = (*fastReflection_BurningAndMintingUnpausedEvent)(nil)

type fastReflection_BurningAndMintingUnpausedEvent BurningAndMintingUnpausedEvent

func (x *BurningAndMintingUnpausedEvent) ProtoReflect() protoreflect.Message {
	return (*fastReflection_BurningAndMintingUnpausedEvent)(x)
}

func (x *BurningAndMintingUnpausedEvent) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_BurningAndMintingUnpausedEvent_messageType fastReflection_BurningAndMintingUnpausedEvent_messageType
var _ protoreflect.MessageType = fastReflection_BurningAndMintingUnpausedEvent_messageType{}

type fastReflection_BurningAndMintingUnpausedEvent_messageType struct{}

func (x fastReflection_BurningAndMintingUnpausedEvent_messageType) Zero() protoreflect.Message {
	return (*fastReflection_BurningAndMintingUnpausedEvent)(nil)
}
func (x fastReflection_BurningAndMintingUnpausedEvent_messageType) New() protoreflect.Message {
	return new(fastReflection_BurningAndMintingUnpausedEvent)
}
func (x fastReflection_BurningAndMintingUnpausedEvent_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_BurningAndMintingUnpausedEvent
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Descriptor() protoreflect.MessageDescriptor {
	return md_BurningAndMintingUnpausedEvent
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Type() protoreflect.MessageType {
	return _fastReflection_BurningAndMintingUnpausedEvent_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_BurningAndMintingUnpausedEvent) New() protoreflect.Message {
	return new(fastReflection_BurningAndMintingUnpausedEvent)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Interface() protoreflect.ProtoMessage {
	return (*BurningAndMintingUnpausedEvent)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingUnpausedEvent does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BurningAndMintingUnpausedEvent) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_BurningAndMintingUnpausedEvent) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.BurningAndMintingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.BurningAndMintingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_BurningAndMintingUnpausedEvent) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.BurningAndMintingUnpausedEvent", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_BurningAndMintingUnpausedEvent) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_BurningAndMintingUnpausedEvent) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_BurningAndMintingUnpausedEvent) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_BurningAndMintingUnpausedEvent) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*BurningAndMintingUnpausedEvent)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*BurningAndMintingUnpausedEvent)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*BurningAndMintingUnpausedEvent)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BurningAndMintingUnpausedEvent: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: BurningAndMintingUnpausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_SendingAndReceivingPausedEvent protoreflect.MessageDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_SendingAndReceivingPausedEvent = File_circle_cctp_v1_events_proto.Messages().ByName("SendingAndReceivingPausedEvent")
}

var _ protoreflect.Message = (*fastReflection_SendingAndReceivingPausedEvent)(nil)

type fastReflection_SendingAndReceivingPausedEvent SendingAndReceivingPausedEvent

func (x *SendingAndReceivingPausedEvent) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SendingAndReceivingPausedEvent)(x)
}

func (x *SendingAndReceivingPausedEvent) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SendingAndReceivingPausedEvent_messageType fastReflection_SendingAndReceivingPausedEvent_messageType
var _ protoreflect.MessageType = fastReflection_SendingAndReceivingPausedEvent_messageType{}

type fastReflection_SendingAndReceivingPausedEvent_messageType struct{}

func (x fastReflection_SendingAndReceivingPausedEvent_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SendingAndReceivingPausedEvent)(nil)
}
func (x fastReflection_SendingAndReceivingPausedEvent_messageType) New() protoreflect.Message {
	return new(fastReflection_SendingAndReceivingPausedEvent)
}
func (x fastReflection_SendingAndReceivingPausedEvent_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SendingAndReceivingPausedEvent
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SendingAndReceivingPausedEvent) Descriptor() protoreflect.MessageDescriptor {
	return md_SendingAndReceivingPausedEvent
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SendingAndReceivingPausedEvent) Type() protoreflect.MessageType {
	return _fastReflection_SendingAndReceivingPausedEvent_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SendingAndReceivingPausedEvent) New() protoreflect.Message {
	return new(fastReflection_SendingAndReceivingPausedEvent)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SendingAndReceivingPausedEvent) Interface() protoreflect.ProtoMessage {
	return (*SendingAndReceivingPausedEvent)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SendingAndReceivingPausedEvent) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SendingAndReceivingPausedEvent) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SendingAndReceivingPausedEvent) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SendingAndReceivingPausedEvent) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingPausedEvent does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SendingAndReceivingPausedEvent) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SendingAndReceivingPausedEvent) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SendingAndReceivingPausedEvent) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingPausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingPausedEvent does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SendingAndReceivingPausedEvent) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.SendingAndReceivingPausedEvent", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SendingAndReceivingPausedEvent) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SendingAndReceivingPausedEvent) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SendingAndReceivingPausedEvent) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SendingAndReceivingPausedEvent) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SendingAndReceivingPausedEvent)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SendingAndReceivingPausedEvent)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SendingAndReceivingPausedEvent)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SendingAndReceivingPausedEvent: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SendingAndReceivingPausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_SendingAndReceivingUnpausedEvent protoreflect.MessageDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_SendingAndReceivingUnpausedEvent = File_circle_cctp_v1_events_proto.Messages().ByName("SendingAndReceivingUnpausedEvent")
}

var _ protoreflect.Message = (*fastReflection_SendingAndReceivingUnpausedEvent)(nil)

type fastReflection_SendingAndReceivingUnpausedEvent SendingAndReceivingUnpausedEvent

func (x *SendingAndReceivingUnpausedEvent) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SendingAndReceivingUnpausedEvent)(x)
}

func (x *SendingAndReceivingUnpausedEvent) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SendingAndReceivingUnpausedEvent_messageType fastReflection_SendingAndReceivingUnpausedEvent_messageType
var _ protoreflect.MessageType = fastReflection_SendingAndReceivingUnpausedEvent_messageType{}

type fastReflection_SendingAndReceivingUnpausedEvent_messageType struct{}

func (x fastReflection_SendingAndReceivingUnpausedEvent_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SendingAndReceivingUnpausedEvent)(nil)
}
func (x fastReflection_SendingAndReceivingUnpausedEvent_messageType) New() protoreflect.Message {
	return new(fastReflection_SendingAndReceivingUnpausedEvent)
}
func (x fastReflection_SendingAndReceivingUnpausedEvent_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SendingAndReceivingUnpausedEvent
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Descriptor() protoreflect.MessageDescriptor {
	return md_SendingAndReceivingUnpausedEvent
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Type() protoreflect.MessageType {
	return _fastReflection_SendingAndReceivingUnpausedEvent_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) New() protoreflect.Message {
	return new(fastReflection_SendingAndReceivingUnpausedEvent)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Interface() protoreflect.ProtoMessage {
	return (*SendingAndReceivingUnpausedEvent)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingUnpausedEvent does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SendingAndReceivingUnpausedEvent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SendingAndReceivingUnpausedEvent does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.SendingAndReceivingUnpausedEvent", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SendingAndReceivingUnpausedEvent) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SendingAndReceivingUnpausedEvent)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SendingAndReceivingUnpausedEvent)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SendingAndReceivingUnpausedEvent)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SendingAndReceivingUnpausedEvent: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SendingAndReceivingUnpausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_DepositForBurn                             protoreflect.MessageDescriptor
	fd_DepositForBurn_nonce                       protoreflect.FieldDescriptor
	fd_DepositForBurn_burn_token                  protoreflect.FieldDescriptor
	fd_DepositForBurn_amount                      protoreflect.FieldDescriptor
	fd_DepositForBurn_depositor                   protoreflect.FieldDescriptor
	fd_DepositForBurn_mint_recipient              protoreflect.FieldDescriptor
	fd_DepositForBurn_destination_domain          protoreflect.FieldDescriptor
	fd_DepositForBurn_destination_token_messenger protoreflect.FieldDescriptor
	fd_DepositForBurn_destination_caller          protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_DepositForBurn = File_circle_cctp_v1_events_proto.Messages().ByName("DepositForBurn")
	fd_DepositForBurn_nonce = md_DepositForBurn.Fields().ByName("nonce")
	fd_DepositForBurn_burn_token = md_DepositForBurn.Fields().ByName("burn_token")
	fd_DepositForBurn_amount = md_DepositForBurn.Fields().ByName("amount")
	fd_DepositForBurn_depositor = md_DepositForBurn.Fields().ByName("depositor")
	fd_DepositForBurn_mint_recipient = md_DepositForBurn.Fields().ByName("mint_recipient")
	fd_DepositForBurn_destination_domain = md_DepositForBurn.Fields().ByName("destination_domain")
	fd_DepositForBurn_destination_token_messenger = md_DepositForBurn.Fields().ByName("destination_token_messenger")
	fd_DepositForBurn_destination_caller = md_DepositForBurn.Fields().ByName("destination_caller")
}

var _ protoreflect.Message = (*fastReflection_DepositForBurn)(nil)

type fastReflection_DepositForBurn DepositForBurn

func (x *DepositForBurn) ProtoReflect() protoreflect.Message {
	return (*fastReflection_DepositForBurn)(x)
}

func (x *DepositForBurn) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_DepositForBurn_messageType fastReflection_DepositForBurn_messageType
var _ protoreflect.MessageType = fastReflection_DepositForBurn_messageType{}

type fastReflection_DepositForBurn_messageType struct{}

func (x fastReflection_DepositForBurn_messageType) Zero() protoreflect.Message {
	return (*fastReflection_DepositForBurn)(nil)
}
func (x fastReflection_DepositForBurn_messageType) New() protoreflect.Message {
	return new(fastReflection_DepositForBurn)
}
func (x fastReflection_DepositForBurn_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositForBurn
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_DepositForBurn) Descriptor() protoreflect.MessageDescriptor {
	return md_DepositForBurn
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_DepositForBurn) Type() protoreflect.MessageType {
	return _fastReflection_DepositForBurn_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_DepositForBurn) New() protoreflect.Message {
	return new(fastReflection_DepositForBurn)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_DepositForBurn) Interface() protoreflect.ProtoMessage {
	return (*DepositForBurn)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_DepositForBurn) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Nonce != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Nonce)
		if !f(fd_DepositForBurn_nonce, value) {
			return
		}
	}
	if x.BurnToken != "" {
		value := protoreflect.ValueOfString(x.BurnToken)
		if !f(fd_DepositForBurn_burn_token, value) {
			return
		}
	}
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_DepositForBurn_amount, value) {
			return
		}
	}
	if x.Depositor != "" {
		value := protoreflect.ValueOfString(x.Depositor)
		if !f(fd_DepositForBurn_depositor, value) {
			return
		}
	}
	if len(x.MintRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.MintRecipient)
		if !f(fd_DepositForBurn_mint_recipient, value) {
			return
		}
	}
	if x.DestinationDomain != uint32(0) {
		value := protoreflect.ValueOfUint32(x.DestinationDomain)
		if !f(fd_DepositForBurn_destination_domain, value) {
			return
		}
	}
	if len(x.DestinationTokenMessenger) != 0 {
		value := protoreflect.ValueOfBytes(x.DestinationTokenMessenger)
		if !f(fd_DepositForBurn_destination_token_messenger, value) {
			return
		}
	}
	if len(x.DestinationCaller) != 0 {
		value := protoreflect.ValueOfBytes(x.DestinationCaller)
		if !f(fd_DepositForBurn_destination_caller, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_DepositForBurn) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.DepositForBurn.nonce":
		return x.Nonce != uint64(0)
	case "circle.cctp.v1.DepositForBurn.burn_token":
		return x.BurnToken != ""
	case "circle.cctp.v1.DepositForBurn.amount":
		return x.Amount != ""
	case "circle.cctp.v1.DepositForBurn.depositor":
		return x.Depositor != ""
	case "circle.cctp.v1.DepositForBurn.mint_recipient":
		return len(x.MintRecipient) != 0
	case "circle.cctp.v1.DepositForBurn.destination_domain":
		return x.DestinationDomain != uint32(0)
	case "circle.cctp.v1.DepositForBurn.destination_token_messenger":
		return len(x.DestinationTokenMessenger) != 0
	case "circle.cctp.v1.DepositForBurn.destination_caller":
		return len(x.DestinationCaller) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.DepositForBurn"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.DepositForBurn does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositForBurn) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.DepositForBurn.nonce":
		x.Nonce = uint64(0)
	case "circle.cctp.v1.DepositForBurn.burn_token":
		x.BurnToken = ""
	case "circle.cctp.v1.DepositForBurn.amount":
		x.Amount = ""
	case "circle.cctp.v1.DepositForBurn.depositor":
		x.Depositor = ""
	case "circle.cctp.v1.DepositForBurn.mint_recipient":
		x.MintRecipient = nil
	case "circle.cctp.v1.DepositForBurn.destination_domain":
		x.DestinationDomain = uint32(0)
	case "circle.cctp.v1.DepositForBurn.destination_token_messenger":
		x.DestinationTokenMessenger = nil
	case "circle.cctp.v1.DepositForBurn.destination_caller":
		x.DestinationCaller = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.DepositForBurn"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.DepositForBurn does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_DepositForBurn) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.DepositForBurn.nonce":
		value := x.Nonce
		return protoreflect.ValueOfUint64(value)
	case "circle.cctp.v1.DepositForBurn.burn_token":
		value := x.BurnToken
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.DepositForBurn.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.DepositForBurn.depositor":
		value := x.Depositor
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.DepositForBurn.mint_recipient":
		value := x.MintRecipient
		return protoreflect.ValueOfBytes(value)
	case "circle.cctp.v1.DepositForBurn.destination_domain":
		value := x.DestinationDomain
		return protoreflect.ValueOfUint32(value)
	case "circle.cctp.v1.DepositForBurn.destination_token_messenger":
		value := x.DestinationTokenMessenger
		return protoreflect.ValueOfBytes(value)
	case "circle.cctp.v1.DepositForBurn.destination_caller":
		value := x.DestinationCaller
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.DepositForBurn"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.DepositForBurn does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositForBurn) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.DepositForBurn.nonce":
		x.Nonce = value.Uint()
	case "circle.cctp.v1.DepositForBurn.burn_token":
		x.BurnToken = value.Interface().(string)
	case "circle.cctp.v1.DepositForBurn.amount":
		x.Amount = value.Interface().(string)
	case "circle.cctp.v1.DepositForBurn.depositor":
		x.Depositor = value.Interface().(string)
	case "circle.cctp.v1.DepositForBurn.mint_recipient":
		x.MintRecipient = value.Bytes()
	case "circle.cctp.v1.DepositForBurn.destination_domain":
		x.DestinationDomain = uint32(value.Uint())
	case "circle.cctp.v1.DepositForBurn.destination_token_messenger":
		x.DestinationTokenMessenger = value.Bytes()
	case "circle.cctp.v1.DepositForBurn.destination_caller":
		x.DestinationCaller = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.DepositForBurn"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.DepositForBurn does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositForBurn) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.DepositForBurn.nonce":
		panic(fmt.Errorf("field nonce of message circle.cctp.v1.DepositForBurn is not mutable"))
	case "circle.cctp.v1.DepositForBurn.burn_token":
		panic(fmt.Errorf("field burn_token of message circle.cctp.v1.DepositForBurn is not mutable"))
	case "circle.cctp.v1.DepositForBurn.amount":
		panic(fmt.Errorf("field amount of message circle.cctp.v1.DepositForBurn is not mutable"))
	case "circle.cctp.v1.DepositForBurn.depositor":
		panic(fmt.Errorf("field depositor of message circle.cctp.v1.DepositForBurn is not mutable"))
	case "circle.cctp.v1.DepositForBurn.mint_recipient":
		panic(fmt.Errorf("field mint_recipient of message circle.cctp.v1.DepositForBurn is not mutable"))
	case "circle.cctp.v1.DepositForBurn.destination_domain":
		panic(fmt.Errorf("field destination_domain of message circle.cctp.v1.DepositForBurn is not mutable"))
	case "circle.cctp.v1.DepositForBurn.destination_token_messenger":
		panic(fmt.Errorf("field destination_token_messenger of message circle.cctp.v1.DepositForBurn is not mutable"))
	case "circle.cctp.v1.DepositForBurn.destination_caller":
		panic(fmt.Errorf("field destination_caller of message circle.cctp.v1.DepositForBurn is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.DepositForBurn"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.DepositForBurn does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_DepositForBurn) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.DepositForBurn.nonce":
		return protoreflect.ValueOfUint64(uint64(0))
	case "circle.cctp.v1.DepositForBurn.burn_token":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.DepositForBurn.amount":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.DepositForBurn.depositor":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.DepositForBurn.mint_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "circle.cctp.v1.DepositForBurn.destination_domain":
		return protoreflect.ValueOfUint32(uint32(0))
	case "circle.cctp.v1.DepositForBurn.destination_token_messenger":
		return protoreflect.ValueOfBytes(nil)
	case "circle.cctp.v1.DepositForBurn.destination_caller":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.DepositForBurn"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.DepositForBurn does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_DepositForBurn) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.DepositForBurn", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_DepositForBurn) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_DepositForBurn) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_DepositForBurn) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_DepositForBurn) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*DepositForBurn)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Nonce != 0 {
			n += 1 + runtime.Sov(uint64(x.Nonce))
		}
		l = len(x.BurnToken)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Depositor)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MintRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.DestinationDomain != 0 {
			n += 1 + runtime.Sov(uint64(x.DestinationDomain))
		}
		l = len(x.DestinationTokenMessenger)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.DestinationCaller)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*DepositForBurn)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.DestinationCaller) > 0 {
			i -= len(x.DestinationCaller)
			copy(dAtA[i:], x.DestinationCaller)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DestinationCaller)))
			i--
			dAtA[i] = 0x42
		}
		if len(x.DestinationTokenMessenger) > 0 {
			i -= len(x.DestinationTokenMessenger)
			copy(dAtA[i:], x.DestinationTokenMessenger)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.DestinationTokenMessenger)))
			i--
			dAtA[i] = 0x3a
		}
		if x.DestinationDomain != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.DestinationDomain))
			i--
			dAtA[i] = 0x30
		}
		if len(x.MintRecipient) > 0 {
			i -= len(x.MintRecipient)
			copy(dAtA[i:], x.MintRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MintRecipient)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Depositor) > 0 {
			i -= len(x.Depositor)
			copy(dAtA[i:], x.Depositor)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Depositor)))
			i--
			dAtA[i] = 0x22
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.BurnToken) > 0 {
			i -= len(x.BurnToken)
			copy(dAtA[i:], x.BurnToken)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BurnToken)))
			i--
			dAtA[i] = 0x12
		}
		if x.Nonce != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Nonce))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*DepositForBurn)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositForBurn: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: DepositForBurn: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				x.Nonce = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Nonce |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BurnToken", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BurnToken = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Depositor = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MintRecipient = append(x.MintRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.MintRecipient == nil {
					x.MintRecipient = []byte{}
				}
				iNdEx = postIndex
			case 6:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
				}
				x.DestinationDomain = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.DestinationDomain |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 7:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DestinationTokenMessenger", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DestinationTokenMessenger = append(x.DestinationTokenMessenger[:0], dAtA[iNdEx:postIndex]...)
				if x.DestinationTokenMessenger == nil {
					x.DestinationTokenMessenger = []byte{}
				}
				iNdEx = postIndex
			case 8:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field DestinationCaller", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.DestinationCaller = append(x.DestinationCaller[:0], dAtA[iNdEx:postIndex]...)
				if x.DestinationCaller == nil {
					x.DestinationCaller = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MintAndWithdraw                protoreflect.MessageDescriptor
	fd_MintAndWithdraw_mint_recipient protoreflect.FieldDescriptor
	fd_MintAndWithdraw_amount         protoreflect.FieldDescriptor
	fd_MintAndWithdraw_mint_token     protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_MintAndWithdraw = File_circle_cctp_v1_events_proto.Messages().ByName("MintAndWithdraw")
	fd_MintAndWithdraw_mint_recipient = md_MintAndWithdraw.Fields().ByName("mint_recipient")
	fd_MintAndWithdraw_amount = md_MintAndWithdraw.Fields().ByName("amount")
	fd_MintAndWithdraw_mint_token = md_MintAndWithdraw.Fields().ByName("mint_token")
}

var _ protoreflect.Message = (*fastReflection_MintAndWithdraw)(nil)

type fastReflection_MintAndWithdraw MintAndWithdraw

func (x *MintAndWithdraw) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MintAndWithdraw)(x)
}

func (x *MintAndWithdraw) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MintAndWithdraw_messageType fastReflection_MintAndWithdraw_messageType
var _ protoreflect.MessageType = fastReflection_MintAndWithdraw_messageType{}

type fastReflection_MintAndWithdraw_messageType struct{}

func (x fastReflection_MintAndWithdraw_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MintAndWithdraw)(nil)
}
func (x fastReflection_MintAndWithdraw_messageType) New() protoreflect.Message {
	return new(fastReflection_MintAndWithdraw)
}
func (x fastReflection_MintAndWithdraw_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MintAndWithdraw
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MintAndWithdraw) Descriptor() protoreflect.MessageDescriptor {
	return md_MintAndWithdraw
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MintAndWithdraw) Type() protoreflect.MessageType {
	return _fastReflection_MintAndWithdraw_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MintAndWithdraw) New() protoreflect.Message {
	return new(fastReflection_MintAndWithdraw)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MintAndWithdraw) Interface() protoreflect.ProtoMessage {
	return (*MintAndWithdraw)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MintAndWithdraw) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.MintRecipient) != 0 {
		value := protoreflect.ValueOfBytes(x.MintRecipient)
		if !f(fd_MintAndWithdraw_mint_recipient, value) {
			return
		}
	}
	if x.Amount != "" {
		value := protoreflect.ValueOfString(x.Amount)
		if !f(fd_MintAndWithdraw_amount, value) {
			return
		}
	}
	if x.MintToken != "" {
		value := protoreflect.ValueOfString(x.MintToken)
		if !f(fd_MintAndWithdraw_mint_token, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MintAndWithdraw) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.MintAndWithdraw.mint_recipient":
		return len(x.MintRecipient) != 0
	case "circle.cctp.v1.MintAndWithdraw.amount":
		return x.Amount != ""
	case "circle.cctp.v1.MintAndWithdraw.mint_token":
		return x.MintToken != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MintAndWithdraw"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MintAndWithdraw does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MintAndWithdraw) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.MintAndWithdraw.mint_recipient":
		x.MintRecipient = nil
	case "circle.cctp.v1.MintAndWithdraw.amount":
		x.Amount = ""
	case "circle.cctp.v1.MintAndWithdraw.mint_token":
		x.MintToken = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MintAndWithdraw"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MintAndWithdraw does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MintAndWithdraw) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.MintAndWithdraw.mint_recipient":
		value := x.MintRecipient
		return protoreflect.ValueOfBytes(value)
	case "circle.cctp.v1.MintAndWithdraw.amount":
		value := x.Amount
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.MintAndWithdraw.mint_token":
		value := x.MintToken
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MintAndWithdraw"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MintAndWithdraw does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MintAndWithdraw) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.MintAndWithdraw.mint_recipient":
		x.MintRecipient = value.Bytes()
	case "circle.cctp.v1.MintAndWithdraw.amount":
		x.Amount = value.Interface().(string)
	case "circle.cctp.v1.MintAndWithdraw.mint_token":
		x.MintToken = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MintAndWithdraw"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MintAndWithdraw does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MintAndWithdraw) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.MintAndWithdraw.mint_recipient":
		panic(fmt.Errorf("field mint_recipient of message circle.cctp.v1.MintAndWithdraw is not mutable"))
	case "circle.cctp.v1.MintAndWithdraw.amount":
		panic(fmt.Errorf("field amount of message circle.cctp.v1.MintAndWithdraw is not mutable"))
	case "circle.cctp.v1.MintAndWithdraw.mint_token":
		panic(fmt.Errorf("field mint_token of message circle.cctp.v1.MintAndWithdraw is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MintAndWithdraw"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MintAndWithdraw does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MintAndWithdraw) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.MintAndWithdraw.mint_recipient":
		return protoreflect.ValueOfBytes(nil)
	case "circle.cctp.v1.MintAndWithdraw.amount":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.MintAndWithdraw.mint_token":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MintAndWithdraw"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MintAndWithdraw does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MintAndWithdraw) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.MintAndWithdraw", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MintAndWithdraw) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MintAndWithdraw) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MintAndWithdraw) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MintAndWithdraw) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MintAndWithdraw)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.MintRecipient)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.Amount)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MintToken)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MintAndWithdraw)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.MintToken) > 0 {
			i -= len(x.MintToken)
			copy(dAtA[i:], x.MintToken)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MintToken)))
			i--
			dAtA[i] = 0x1a
		}
		if len(x.Amount) > 0 {
			i -= len(x.Amount)
			copy(dAtA[i:], x.Amount)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Amount)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.MintRecipient) > 0 {
			i -= len(x.MintRecipient)
			copy(dAtA[i:], x.MintRecipient)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MintRecipient)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MintAndWithdraw)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MintAndWithdraw: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MintAndWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MintRecipient = append(x.MintRecipient[:0], dAtA[iNdEx:postIndex]...)
				if x.MintRecipient == nil {
					x.MintRecipient = []byte{}
				}
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Amount = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MintToken", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MintToken = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_TokenPairLinked               protoreflect.MessageDescriptor
	fd_TokenPairLinked_local_token   protoreflect.FieldDescriptor
	fd_TokenPairLinked_remote_domain protoreflect.FieldDescriptor
	fd_TokenPairLinked_remote_token  protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_TokenPairLinked = File_circle_cctp_v1_events_proto.Messages().ByName("TokenPairLinked")
	fd_TokenPairLinked_local_token = md_TokenPairLinked.Fields().ByName("local_token")
	fd_TokenPairLinked_remote_domain = md_TokenPairLinked.Fields().ByName("remote_domain")
	fd_TokenPairLinked_remote_token = md_TokenPairLinked.Fields().ByName("remote_token")
}

var _ protoreflect.Message = (*fastReflection_TokenPairLinked)(nil)

type fastReflection_TokenPairLinked TokenPairLinked

func (x *TokenPairLinked) ProtoReflect() protoreflect.Message {
	return (*fastReflection_TokenPairLinked)(x)
}

func (x *TokenPairLinked) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_TokenPairLinked_messageType fastReflection_TokenPairLinked_messageType
var _ protoreflect.MessageType = fastReflection_TokenPairLinked_messageType{}

type fastReflection_TokenPairLinked_messageType struct{}

func (x fastReflection_TokenPairLinked_messageType) Zero() protoreflect.Message {
	return (*fastReflection_TokenPairLinked)(nil)
}
func (x fastReflection_TokenPairLinked_messageType) New() protoreflect.Message {
	return new(fastReflection_TokenPairLinked)
}
func (x fastReflection_TokenPairLinked_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_TokenPairLinked
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_TokenPairLinked) Descriptor() protoreflect.MessageDescriptor {
	return md_TokenPairLinked
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_TokenPairLinked) Type() protoreflect.MessageType {
	return _fastReflection_TokenPairLinked_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_TokenPairLinked) New() protoreflect.Message {
	return new(fastReflection_TokenPairLinked)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_TokenPairLinked) Interface() protoreflect.ProtoMessage {
	return (*TokenPairLinked)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_TokenPairLinked) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.LocalToken != "" {
		value := protoreflect.ValueOfString(x.LocalToken)
		if !f(fd_TokenPairLinked_local_token, value) {
			return
		}
	}
	if x.RemoteDomain != uint32(0) {
		value := protoreflect.ValueOfUint32(x.RemoteDomain)
		if !f(fd_TokenPairLinked_remote_domain, value) {
			return
		}
	}
	if len(x.RemoteToken) != 0 {
		value := protoreflect.ValueOfBytes(x.RemoteToken)
		if !f(fd_TokenPairLinked_remote_token, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_TokenPairLinked) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairLinked.local_token":
		return x.LocalToken != ""
	case "circle.cctp.v1.TokenPairLinked.remote_domain":
		return x.RemoteDomain != uint32(0)
	case "circle.cctp.v1.TokenPairLinked.remote_token":
		return len(x.RemoteToken) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairLinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairLinked does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenPairLinked) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairLinked.local_token":
		x.LocalToken = ""
	case "circle.cctp.v1.TokenPairLinked.remote_domain":
		x.RemoteDomain = uint32(0)
	case "circle.cctp.v1.TokenPairLinked.remote_token":
		x.RemoteToken = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairLinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairLinked does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_TokenPairLinked) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.TokenPairLinked.local_token":
		value := x.LocalToken
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.TokenPairLinked.remote_domain":
		value := x.RemoteDomain
		return protoreflect.ValueOfUint32(value)
	case "circle.cctp.v1.TokenPairLinked.remote_token":
		value := x.RemoteToken
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairLinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairLinked does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenPairLinked) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairLinked.local_token":
		x.LocalToken = value.Interface().(string)
	case "circle.cctp.v1.TokenPairLinked.remote_domain":
		x.RemoteDomain = uint32(value.Uint())
	case "circle.cctp.v1.TokenPairLinked.remote_token":
		x.RemoteToken = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairLinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairLinked does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenPairLinked) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairLinked.local_token":
		panic(fmt.Errorf("field local_token of message circle.cctp.v1.TokenPairLinked is not mutable"))
	case "circle.cctp.v1.TokenPairLinked.remote_domain":
		panic(fmt.Errorf("field remote_domain of message circle.cctp.v1.TokenPairLinked is not mutable"))
	case "circle.cctp.v1.TokenPairLinked.remote_token":
		panic(fmt.Errorf("field remote_token of message circle.cctp.v1.TokenPairLinked is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairLinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairLinked does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_TokenPairLinked) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairLinked.local_token":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.TokenPairLinked.remote_domain":
		return protoreflect.ValueOfUint32(uint32(0))
	case "circle.cctp.v1.TokenPairLinked.remote_token":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairLinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairLinked does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_TokenPairLinked) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.TokenPairLinked", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_TokenPairLinked) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenPairLinked) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_TokenPairLinked) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_TokenPairLinked) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*TokenPairLinked)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.LocalToken)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RemoteDomain != 0 {
			n += 1 + runtime.Sov(uint64(x.RemoteDomain))
		}
		l = len(x.RemoteToken)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*TokenPairLinked)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.RemoteToken) > 0 {
			i -= len(x.RemoteToken)
			copy(dAtA[i:], x.RemoteToken)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RemoteToken)))
			i--
			dAtA[i] = 0x1a
		}
		if x.RemoteDomain != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.RemoteDomain))
			i--
			dAtA[i] = 0x10
		}
		if len(x.LocalToken) > 0 {
			i -= len(x.LocalToken)
			copy(dAtA[i:], x.LocalToken)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LocalToken)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*TokenPairLinked)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TokenPairLinked: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TokenPairLinked: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LocalToken = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
				}
				x.RemoteDomain = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.RemoteDomain |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RemoteToken = append(x.RemoteToken[:0], dAtA[iNdEx:postIndex]...)
				if x.RemoteToken == nil {
					x.RemoteToken = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_TokenPairUnlinked               protoreflect.MessageDescriptor
	fd_TokenPairUnlinked_local_token   protoreflect.FieldDescriptor
	fd_TokenPairUnlinked_remote_domain protoreflect.FieldDescriptor
	fd_TokenPairUnlinked_remote_token  protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_TokenPairUnlinked = File_circle_cctp_v1_events_proto.Messages().ByName("TokenPairUnlinked")
	fd_TokenPairUnlinked_local_token = md_TokenPairUnlinked.Fields().ByName("local_token")
	fd_TokenPairUnlinked_remote_domain = md_TokenPairUnlinked.Fields().ByName("remote_domain")
	fd_TokenPairUnlinked_remote_token = md_TokenPairUnlinked.Fields().ByName("remote_token")
}

var _ protoreflect.Message = (*fastReflection_TokenPairUnlinked)(nil)

type fastReflection_TokenPairUnlinked TokenPairUnlinked

func (x *TokenPairUnlinked) ProtoReflect() protoreflect.Message {
	return (*fastReflection_TokenPairUnlinked)(x)
}

func (x *TokenPairUnlinked) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_TokenPairUnlinked_messageType fastReflection_TokenPairUnlinked_messageType
var _ protoreflect.MessageType = fastReflection_TokenPairUnlinked_messageType{}

type fastReflection_TokenPairUnlinked_messageType struct{}

func (x fastReflection_TokenPairUnlinked_messageType) Zero() protoreflect.Message {
	return (*fastReflection_TokenPairUnlinked)(nil)
}
func (x fastReflection_TokenPairUnlinked_messageType) New() protoreflect.Message {
	return new(fastReflection_TokenPairUnlinked)
}
func (x fastReflection_TokenPairUnlinked_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_TokenPairUnlinked
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_TokenPairUnlinked) Descriptor() protoreflect.MessageDescriptor {
	return md_TokenPairUnlinked
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_TokenPairUnlinked) Type() protoreflect.MessageType {
	return _fastReflection_TokenPairUnlinked_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_TokenPairUnlinked) New() protoreflect.Message {
	return new(fastReflection_TokenPairUnlinked)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_TokenPairUnlinked) Interface() protoreflect.ProtoMessage {
	return (*TokenPairUnlinked)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_TokenPairUnlinked) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.LocalToken != "" {
		value := protoreflect.ValueOfString(x.LocalToken)
		if !f(fd_TokenPairUnlinked_local_token, value) {
			return
		}
	}
	if x.RemoteDomain != uint32(0) {
		value := protoreflect.ValueOfUint32(x.RemoteDomain)
		if !f(fd_TokenPairUnlinked_remote_domain, value) {
			return
		}
	}
	if len(x.RemoteToken) != 0 {
		value := protoreflect.ValueOfBytes(x.RemoteToken)
		if !f(fd_TokenPairUnlinked_remote_token, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_TokenPairUnlinked) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairUnlinked.local_token":
		return x.LocalToken != ""
	case "circle.cctp.v1.TokenPairUnlinked.remote_domain":
		return x.RemoteDomain != uint32(0)
	case "circle.cctp.v1.TokenPairUnlinked.remote_token":
		return len(x.RemoteToken) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairUnlinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairUnlinked does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenPairUnlinked) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairUnlinked.local_token":
		x.LocalToken = ""
	case "circle.cctp.v1.TokenPairUnlinked.remote_domain":
		x.RemoteDomain = uint32(0)
	case "circle.cctp.v1.TokenPairUnlinked.remote_token":
		x.RemoteToken = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairUnlinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairUnlinked does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_TokenPairUnlinked) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.TokenPairUnlinked.local_token":
		value := x.LocalToken
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.TokenPairUnlinked.remote_domain":
		value := x.RemoteDomain
		return protoreflect.ValueOfUint32(value)
	case "circle.cctp.v1.TokenPairUnlinked.remote_token":
		value := x.RemoteToken
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairUnlinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairUnlinked does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenPairUnlinked) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairUnlinked.local_token":
		x.LocalToken = value.Interface().(string)
	case "circle.cctp.v1.TokenPairUnlinked.remote_domain":
		x.RemoteDomain = uint32(value.Uint())
	case "circle.cctp.v1.TokenPairUnlinked.remote_token":
		x.RemoteToken = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairUnlinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairUnlinked does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenPairUnlinked) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairUnlinked.local_token":
		panic(fmt.Errorf("field local_token of message circle.cctp.v1.TokenPairUnlinked is not mutable"))
	case "circle.cctp.v1.TokenPairUnlinked.remote_domain":
		panic(fmt.Errorf("field remote_domain of message circle.cctp.v1.TokenPairUnlinked is not mutable"))
	case "circle.cctp.v1.TokenPairUnlinked.remote_token":
		panic(fmt.Errorf("field remote_token of message circle.cctp.v1.TokenPairUnlinked is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairUnlinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairUnlinked does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_TokenPairUnlinked) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.TokenPairUnlinked.local_token":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.TokenPairUnlinked.remote_domain":
		return protoreflect.ValueOfUint32(uint32(0))
	case "circle.cctp.v1.TokenPairUnlinked.remote_token":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.TokenPairUnlinked"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.TokenPairUnlinked does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_TokenPairUnlinked) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.TokenPairUnlinked", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_TokenPairUnlinked) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_TokenPairUnlinked) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_TokenPairUnlinked) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_TokenPairUnlinked) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*TokenPairUnlinked)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.LocalToken)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.RemoteDomain != 0 {
			n += 1 + runtime.Sov(uint64(x.RemoteDomain))
		}
		l = len(x.RemoteToken)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*TokenPairUnlinked)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.RemoteToken) > 0 {
			i -= len(x.RemoteToken)
			copy(dAtA[i:], x.RemoteToken)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RemoteToken)))
			i--
			dAtA[i] = 0x1a
		}
		if x.RemoteDomain != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.RemoteDomain))
			i--
			dAtA[i] = 0x10
		}
		if len(x.LocalToken) > 0 {
			i -= len(x.LocalToken)
			copy(dAtA[i:], x.LocalToken)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.LocalToken)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*TokenPairUnlinked)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TokenPairUnlinked: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: TokenPairUnlinked: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.LocalToken = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
				}
				x.RemoteDomain = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.RemoteDomain |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RemoteToken = append(x.RemoteToken[:0], dAtA[iNdEx:postIndex]...)
				if x.RemoteToken == nil {
					x.RemoteToken = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MessageSent         protoreflect.MessageDescriptor
	fd_MessageSent_message protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_MessageSent = File_circle_cctp_v1_events_proto.Messages().ByName("MessageSent")
	fd_MessageSent_message = md_MessageSent.Fields().ByName("message")
}

var _ protoreflect.Message = (*fastReflection_MessageSent)(nil)

type fastReflection_MessageSent MessageSent

func (x *MessageSent) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MessageSent)(x)
}

func (x *MessageSent) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MessageSent_messageType fastReflection_MessageSent_messageType
var _ protoreflect.MessageType = fastReflection_MessageSent_messageType{}

type fastReflection_MessageSent_messageType struct{}

func (x fastReflection_MessageSent_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MessageSent)(nil)
}
func (x fastReflection_MessageSent_messageType) New() protoreflect.Message {
	return new(fastReflection_MessageSent)
}
func (x fastReflection_MessageSent_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MessageSent
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MessageSent) Descriptor() protoreflect.MessageDescriptor {
	return md_MessageSent
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MessageSent) Type() protoreflect.MessageType {
	return _fastReflection_MessageSent_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MessageSent) New() protoreflect.Message {
	return new(fastReflection_MessageSent)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MessageSent) Interface() protoreflect.ProtoMessage {
	return (*MessageSent)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MessageSent) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if len(x.Message) != 0 {
		value := protoreflect.ValueOfBytes(x.Message)
		if !f(fd_MessageSent_message, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MessageSent) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageSent.message":
		return len(x.Message) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageSent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageSent does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MessageSent) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageSent.message":
		x.Message = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageSent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageSent does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MessageSent) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.MessageSent.message":
		value := x.Message
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageSent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageSent does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MessageSent) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageSent.message":
		x.Message = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageSent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageSent does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MessageSent) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageSent.message":
		panic(fmt.Errorf("field message of message circle.cctp.v1.MessageSent is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageSent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageSent does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MessageSent) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageSent.message":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageSent"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageSent does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MessageSent) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.MessageSent", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MessageSent) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MessageSent) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MessageSent) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MessageSent) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MessageSent)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Message)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MessageSent)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.Message) > 0 {
			i -= len(x.Message)
			copy(dAtA[i:], x.Message)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Message)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MessageSent)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MessageSent: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MessageSent: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Message = append(x.Message[:0], dAtA[iNdEx:postIndex]...)
				if x.Message == nil {
					x.Message = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MessageReceived               protoreflect.MessageDescriptor
	fd_MessageReceived_caller        protoreflect.FieldDescriptor
	fd_MessageReceived_source_domain protoreflect.FieldDescriptor
	fd_MessageReceived_nonce         protoreflect.FieldDescriptor
	fd_MessageReceived_sender        protoreflect.FieldDescriptor
	fd_MessageReceived_message_body  protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_MessageReceived = File_circle_cctp_v1_events_proto.Messages().ByName("MessageReceived")
	fd_MessageReceived_caller = md_MessageReceived.Fields().ByName("caller")
	fd_MessageReceived_source_domain = md_MessageReceived.Fields().ByName("source_domain")
	fd_MessageReceived_nonce = md_MessageReceived.Fields().ByName("nonce")
	fd_MessageReceived_sender = md_MessageReceived.Fields().ByName("sender")
	fd_MessageReceived_message_body = md_MessageReceived.Fields().ByName("message_body")
}

var _ protoreflect.Message = (*fastReflection_MessageReceived)(nil)

type fastReflection_MessageReceived MessageReceived

func (x *MessageReceived) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MessageReceived)(x)
}

func (x *MessageReceived) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MessageReceived_messageType fastReflection_MessageReceived_messageType
var _ protoreflect.MessageType = fastReflection_MessageReceived_messageType{}

type fastReflection_MessageReceived_messageType struct{}

func (x fastReflection_MessageReceived_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MessageReceived)(nil)
}
func (x fastReflection_MessageReceived_messageType) New() protoreflect.Message {
	return new(fastReflection_MessageReceived)
}
func (x fastReflection_MessageReceived_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MessageReceived
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MessageReceived) Descriptor() protoreflect.MessageDescriptor {
	return md_MessageReceived
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MessageReceived) Type() protoreflect.MessageType {
	return _fastReflection_MessageReceived_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MessageReceived) New() protoreflect.Message {
	return new(fastReflection_MessageReceived)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MessageReceived) Interface() protoreflect.ProtoMessage {
	return (*MessageReceived)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MessageReceived) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Caller != "" {
		value := protoreflect.ValueOfString(x.Caller)
		if !f(fd_MessageReceived_caller, value) {
			return
		}
	}
	if x.SourceDomain != uint32(0) {
		value := protoreflect.ValueOfUint32(x.SourceDomain)
		if !f(fd_MessageReceived_source_domain, value) {
			return
		}
	}
	if x.Nonce != uint64(0) {
		value := protoreflect.ValueOfUint64(x.Nonce)
		if !f(fd_MessageReceived_nonce, value) {
			return
		}
	}
	if len(x.Sender) != 0 {
		value := protoreflect.ValueOfBytes(x.Sender)
		if !f(fd_MessageReceived_sender, value) {
			return
		}
	}
	if len(x.MessageBody) != 0 {
		value := protoreflect.ValueOfBytes(x.MessageBody)
		if !f(fd_MessageReceived_message_body, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MessageReceived) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageReceived.caller":
		return x.Caller != ""
	case "circle.cctp.v1.MessageReceived.source_domain":
		return x.SourceDomain != uint32(0)
	case "circle.cctp.v1.MessageReceived.nonce":
		return x.Nonce != uint64(0)
	case "circle.cctp.v1.MessageReceived.sender":
		return len(x.Sender) != 0
	case "circle.cctp.v1.MessageReceived.message_body":
		return len(x.MessageBody) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageReceived"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageReceived does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MessageReceived) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageReceived.caller":
		x.Caller = ""
	case "circle.cctp.v1.MessageReceived.source_domain":
		x.SourceDomain = uint32(0)
	case "circle.cctp.v1.MessageReceived.nonce":
		x.Nonce = uint64(0)
	case "circle.cctp.v1.MessageReceived.sender":
		x.Sender = nil
	case "circle.cctp.v1.MessageReceived.message_body":
		x.MessageBody = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageReceived"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageReceived does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MessageReceived) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.MessageReceived.caller":
		value := x.Caller
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.MessageReceived.source_domain":
		value := x.SourceDomain
		return protoreflect.ValueOfUint32(value)
	case "circle.cctp.v1.MessageReceived.nonce":
		value := x.Nonce
		return protoreflect.ValueOfUint64(value)
	case "circle.cctp.v1.MessageReceived.sender":
		value := x.Sender
		return protoreflect.ValueOfBytes(value)
	case "circle.cctp.v1.MessageReceived.message_body":
		value := x.MessageBody
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageReceived"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageReceived does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MessageReceived) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageReceived.caller":
		x.Caller = value.Interface().(string)
	case "circle.cctp.v1.MessageReceived.source_domain":
		x.SourceDomain = uint32(value.Uint())
	case "circle.cctp.v1.MessageReceived.nonce":
		x.Nonce = value.Uint()
	case "circle.cctp.v1.MessageReceived.sender":
		x.Sender = value.Bytes()
	case "circle.cctp.v1.MessageReceived.message_body":
		x.MessageBody = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageReceived"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageReceived does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MessageReceived) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageReceived.caller":
		panic(fmt.Errorf("field caller of message circle.cctp.v1.MessageReceived is not mutable"))
	case "circle.cctp.v1.MessageReceived.source_domain":
		panic(fmt.Errorf("field source_domain of message circle.cctp.v1.MessageReceived is not mutable"))
	case "circle.cctp.v1.MessageReceived.nonce":
		panic(fmt.Errorf("field nonce of message circle.cctp.v1.MessageReceived is not mutable"))
	case "circle.cctp.v1.MessageReceived.sender":
		panic(fmt.Errorf("field sender of message circle.cctp.v1.MessageReceived is not mutable"))
	case "circle.cctp.v1.MessageReceived.message_body":
		panic(fmt.Errorf("field message_body of message circle.cctp.v1.MessageReceived is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageReceived"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageReceived does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MessageReceived) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.MessageReceived.caller":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.MessageReceived.source_domain":
		return protoreflect.ValueOfUint32(uint32(0))
	case "circle.cctp.v1.MessageReceived.nonce":
		return protoreflect.ValueOfUint64(uint64(0))
	case "circle.cctp.v1.MessageReceived.sender":
		return protoreflect.ValueOfBytes(nil)
	case "circle.cctp.v1.MessageReceived.message_body":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MessageReceived"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MessageReceived does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MessageReceived) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.MessageReceived", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MessageReceived) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MessageReceived) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MessageReceived) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MessageReceived) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MessageReceived)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Caller)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.SourceDomain != 0 {
			n += 1 + runtime.Sov(uint64(x.SourceDomain))
		}
		if x.Nonce != 0 {
			n += 1 + runtime.Sov(uint64(x.Nonce))
		}
		l = len(x.Sender)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.MessageBody)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MessageReceived)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.MessageBody) > 0 {
			i -= len(x.MessageBody)
			copy(dAtA[i:], x.MessageBody)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.MessageBody)))
			i--
			dAtA[i] = 0x2a
		}
		if len(x.Sender) > 0 {
			i -= len(x.Sender)
			copy(dAtA[i:], x.Sender)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Sender)))
			i--
			dAtA[i] = 0x22
		}
		if x.Nonce != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Nonce))
			i--
			dAtA[i] = 0x18
		}
		if x.SourceDomain != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.SourceDomain))
			i--
			dAtA[i] = 0x10
		}
		if len(x.Caller) > 0 {
			i -= len(x.Caller)
			copy(dAtA[i:], x.Caller)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Caller)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MessageReceived)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MessageReceived: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MessageReceived: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Caller = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field SourceDomain", wireType)
				}
				x.SourceDomain = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.SourceDomain |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 3:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
				}
				x.Nonce = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Nonce |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 4:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Sender = append(x.Sender[:0], dAtA[iNdEx:postIndex]...)
				if x.Sender == nil {
					x.Sender = []byte{}
				}
				iNdEx = postIndex
			case 5:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field MessageBody", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.MessageBody = append(x.MessageBody[:0], dAtA[iNdEx:postIndex]...)
				if x.MessageBody == nil {
					x.MessageBody = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_MaxMessageBodySizeUpdated                           protoreflect.MessageDescriptor
	fd_MaxMessageBodySizeUpdated_new_max_message_body_size protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_MaxMessageBodySizeUpdated = File_circle_cctp_v1_events_proto.Messages().ByName("MaxMessageBodySizeUpdated")
	fd_MaxMessageBodySizeUpdated_new_max_message_body_size = md_MaxMessageBodySizeUpdated.Fields().ByName("new_max_message_body_size")
}

var _ protoreflect.Message = (*fastReflection_MaxMessageBodySizeUpdated)(nil)

type fastReflection_MaxMessageBodySizeUpdated MaxMessageBodySizeUpdated

func (x *MaxMessageBodySizeUpdated) ProtoReflect() protoreflect.Message {
	return (*fastReflection_MaxMessageBodySizeUpdated)(x)
}

func (x *MaxMessageBodySizeUpdated) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_MaxMessageBodySizeUpdated_messageType fastReflection_MaxMessageBodySizeUpdated_messageType
var _ protoreflect.MessageType = fastReflection_MaxMessageBodySizeUpdated_messageType{}

type fastReflection_MaxMessageBodySizeUpdated_messageType struct{}

func (x fastReflection_MaxMessageBodySizeUpdated_messageType) Zero() protoreflect.Message {
	return (*fastReflection_MaxMessageBodySizeUpdated)(nil)
}
func (x fastReflection_MaxMessageBodySizeUpdated_messageType) New() protoreflect.Message {
	return new(fastReflection_MaxMessageBodySizeUpdated)
}
func (x fastReflection_MaxMessageBodySizeUpdated_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_MaxMessageBodySizeUpdated
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_MaxMessageBodySizeUpdated) Descriptor() protoreflect.MessageDescriptor {
	return md_MaxMessageBodySizeUpdated
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_MaxMessageBodySizeUpdated) Type() protoreflect.MessageType {
	return _fastReflection_MaxMessageBodySizeUpdated_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_MaxMessageBodySizeUpdated) New() protoreflect.Message {
	return new(fastReflection_MaxMessageBodySizeUpdated)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_MaxMessageBodySizeUpdated) Interface() protoreflect.ProtoMessage {
	return (*MaxMessageBodySizeUpdated)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_MaxMessageBodySizeUpdated) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.NewMaxMessageBodySize != uint64(0) {
		value := protoreflect.ValueOfUint64(x.NewMaxMessageBodySize)
		if !f(fd_MaxMessageBodySizeUpdated_new_max_message_body_size, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_MaxMessageBodySizeUpdated) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.MaxMessageBodySizeUpdated.new_max_message_body_size":
		return x.NewMaxMessageBodySize != uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MaxMessageBodySizeUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MaxMessageBodySizeUpdated does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MaxMessageBodySizeUpdated) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.MaxMessageBodySizeUpdated.new_max_message_body_size":
		x.NewMaxMessageBodySize = uint64(0)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MaxMessageBodySizeUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MaxMessageBodySizeUpdated does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_MaxMessageBodySizeUpdated) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.MaxMessageBodySizeUpdated.new_max_message_body_size":
		value := x.NewMaxMessageBodySize
		return protoreflect.ValueOfUint64(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MaxMessageBodySizeUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MaxMessageBodySizeUpdated does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MaxMessageBodySizeUpdated) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.MaxMessageBodySizeUpdated.new_max_message_body_size":
		x.NewMaxMessageBodySize = value.Uint()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MaxMessageBodySizeUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MaxMessageBodySizeUpdated does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MaxMessageBodySizeUpdated) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.MaxMessageBodySizeUpdated.new_max_message_body_size":
		panic(fmt.Errorf("field new_max_message_body_size of message circle.cctp.v1.MaxMessageBodySizeUpdated is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MaxMessageBodySizeUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MaxMessageBodySizeUpdated does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_MaxMessageBodySizeUpdated) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.MaxMessageBodySizeUpdated.new_max_message_body_size":
		return protoreflect.ValueOfUint64(uint64(0))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.MaxMessageBodySizeUpdated"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.MaxMessageBodySizeUpdated does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_MaxMessageBodySizeUpdated) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.MaxMessageBodySizeUpdated", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_MaxMessageBodySizeUpdated) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_MaxMessageBodySizeUpdated) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_MaxMessageBodySizeUpdated) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_MaxMessageBodySizeUpdated) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*MaxMessageBodySizeUpdated)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.NewMaxMessageBodySize != 0 {
			n += 1 + runtime.Sov(uint64(x.NewMaxMessageBodySize))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*MaxMessageBodySizeUpdated)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if x.NewMaxMessageBodySize != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.NewMaxMessageBodySize))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*MaxMessageBodySizeUpdated)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MaxMessageBodySizeUpdated: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: MaxMessageBodySizeUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field NewMaxMessageBodySize", wireType)
				}
				x.NewMaxMessageBodySize = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.NewMaxMessageBodySize |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_RemoteTokenMessengerAdded                        protoreflect.MessageDescriptor
	fd_RemoteTokenMessengerAdded_domain                 protoreflect.FieldDescriptor
	fd_RemoteTokenMessengerAdded_remote_token_messenger protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_RemoteTokenMessengerAdded = File_circle_cctp_v1_events_proto.Messages().ByName("RemoteTokenMessengerAdded")
	fd_RemoteTokenMessengerAdded_domain = md_RemoteTokenMessengerAdded.Fields().ByName("domain")
	fd_RemoteTokenMessengerAdded_remote_token_messenger = md_RemoteTokenMessengerAdded.Fields().ByName("remote_token_messenger")
}

var _ protoreflect.Message = (*fastReflection_RemoteTokenMessengerAdded)(nil)

type fastReflection_RemoteTokenMessengerAdded RemoteTokenMessengerAdded

func (x *RemoteTokenMessengerAdded) ProtoReflect() protoreflect.Message {
	return (*fastReflection_RemoteTokenMessengerAdded)(x)
}

func (x *RemoteTokenMessengerAdded) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_RemoteTokenMessengerAdded_messageType fastReflection_RemoteTokenMessengerAdded_messageType
var _ protoreflect.MessageType = fastReflection_RemoteTokenMessengerAdded_messageType{}

type fastReflection_RemoteTokenMessengerAdded_messageType struct{}

func (x fastReflection_RemoteTokenMessengerAdded_messageType) Zero() protoreflect.Message {
	return (*fastReflection_RemoteTokenMessengerAdded)(nil)
}
func (x fastReflection_RemoteTokenMessengerAdded_messageType) New() protoreflect.Message {
	return new(fastReflection_RemoteTokenMessengerAdded)
}
func (x fastReflection_RemoteTokenMessengerAdded_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_RemoteTokenMessengerAdded
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_RemoteTokenMessengerAdded) Descriptor() protoreflect.MessageDescriptor {
	return md_RemoteTokenMessengerAdded
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_RemoteTokenMessengerAdded) Type() protoreflect.MessageType {
	return _fastReflection_RemoteTokenMessengerAdded_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_RemoteTokenMessengerAdded) New() protoreflect.Message {
	return new(fastReflection_RemoteTokenMessengerAdded)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_RemoteTokenMessengerAdded) Interface() protoreflect.ProtoMessage {
	return (*RemoteTokenMessengerAdded)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_RemoteTokenMessengerAdded) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Domain != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Domain)
		if !f(fd_RemoteTokenMessengerAdded_domain, value) {
			return
		}
	}
	if len(x.RemoteTokenMessenger) != 0 {
		value := protoreflect.ValueOfBytes(x.RemoteTokenMessenger)
		if !f(fd_RemoteTokenMessengerAdded_remote_token_messenger, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_RemoteTokenMessengerAdded) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerAdded.domain":
		return x.Domain != uint32(0)
	case "circle.cctp.v1.RemoteTokenMessengerAdded.remote_token_messenger":
		return len(x.RemoteTokenMessenger) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerAdded"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerAdded does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemoteTokenMessengerAdded) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerAdded.domain":
		x.Domain = uint32(0)
	case "circle.cctp.v1.RemoteTokenMessengerAdded.remote_token_messenger":
		x.RemoteTokenMessenger = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerAdded"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerAdded does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_RemoteTokenMessengerAdded) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerAdded.domain":
		value := x.Domain
		return protoreflect.ValueOfUint32(value)
	case "circle.cctp.v1.RemoteTokenMessengerAdded.remote_token_messenger":
		value := x.RemoteTokenMessenger
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerAdded"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerAdded does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemoteTokenMessengerAdded) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerAdded.domain":
		x.Domain = uint32(value.Uint())
	case "circle.cctp.v1.RemoteTokenMessengerAdded.remote_token_messenger":
		x.RemoteTokenMessenger = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerAdded"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerAdded does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemoteTokenMessengerAdded) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerAdded.domain":
		panic(fmt.Errorf("field domain of message circle.cctp.v1.RemoteTokenMessengerAdded is not mutable"))
	case "circle.cctp.v1.RemoteTokenMessengerAdded.remote_token_messenger":
		panic(fmt.Errorf("field remote_token_messenger of message circle.cctp.v1.RemoteTokenMessengerAdded is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerAdded"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerAdded does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_RemoteTokenMessengerAdded) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerAdded.domain":
		return protoreflect.ValueOfUint32(uint32(0))
	case "circle.cctp.v1.RemoteTokenMessengerAdded.remote_token_messenger":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerAdded"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerAdded does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_RemoteTokenMessengerAdded) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.RemoteTokenMessengerAdded", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_RemoteTokenMessengerAdded) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemoteTokenMessengerAdded) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_RemoteTokenMessengerAdded) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_RemoteTokenMessengerAdded) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*RemoteTokenMessengerAdded)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Domain != 0 {
			n += 1 + runtime.Sov(uint64(x.Domain))
		}
		l = len(x.RemoteTokenMessenger)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*RemoteTokenMessengerAdded)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.RemoteTokenMessenger) > 0 {
			i -= len(x.RemoteTokenMessenger)
			copy(dAtA[i:], x.RemoteTokenMessenger)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RemoteTokenMessenger)))
			i--
			dAtA[i] = 0x12
		}
		if x.Domain != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Domain))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*RemoteTokenMessengerAdded)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: RemoteTokenMessengerAdded: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: RemoteTokenMessengerAdded: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
				}
				x.Domain = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Domain |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemoteTokenMessenger", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RemoteTokenMessenger = append(x.RemoteTokenMessenger[:0], dAtA[iNdEx:postIndex]...)
				if x.RemoteTokenMessenger == nil {
					x.RemoteTokenMessenger = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_RemoteTokenMessengerRemoved                        protoreflect.MessageDescriptor
	fd_RemoteTokenMessengerRemoved_domain                 protoreflect.FieldDescriptor
	fd_RemoteTokenMessengerRemoved_remote_token_messenger protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_RemoteTokenMessengerRemoved = File_circle_cctp_v1_events_proto.Messages().ByName("RemoteTokenMessengerRemoved")
	fd_RemoteTokenMessengerRemoved_domain = md_RemoteTokenMessengerRemoved.Fields().ByName("domain")
	fd_RemoteTokenMessengerRemoved_remote_token_messenger = md_RemoteTokenMessengerRemoved.Fields().ByName("remote_token_messenger")
}

var _ protoreflect.Message = (*fastReflection_RemoteTokenMessengerRemoved)(nil)

type fastReflection_RemoteTokenMessengerRemoved RemoteTokenMessengerRemoved

func (x *RemoteTokenMessengerRemoved) ProtoReflect() protoreflect.Message {
	return (*fastReflection_RemoteTokenMessengerRemoved)(x)
}

func (x *RemoteTokenMessengerRemoved) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_RemoteTokenMessengerRemoved_messageType fastReflection_RemoteTokenMessengerRemoved_messageType
var _ protoreflect.MessageType = fastReflection_RemoteTokenMessengerRemoved_messageType{}

type fastReflection_RemoteTokenMessengerRemoved_messageType struct{}

func (x fastReflection_RemoteTokenMessengerRemoved_messageType) Zero() protoreflect.Message {
	return (*fastReflection_RemoteTokenMessengerRemoved)(nil)
}
func (x fastReflection_RemoteTokenMessengerRemoved_messageType) New() protoreflect.Message {
	return new(fastReflection_RemoteTokenMessengerRemoved)
}
func (x fastReflection_RemoteTokenMessengerRemoved_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_RemoteTokenMessengerRemoved
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_RemoteTokenMessengerRemoved) Descriptor() protoreflect.MessageDescriptor {
	return md_RemoteTokenMessengerRemoved
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_RemoteTokenMessengerRemoved) Type() protoreflect.MessageType {
	return _fastReflection_RemoteTokenMessengerRemoved_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_RemoteTokenMessengerRemoved) New() protoreflect.Message {
	return new(fastReflection_RemoteTokenMessengerRemoved)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_RemoteTokenMessengerRemoved) Interface() protoreflect.ProtoMessage {
	return (*RemoteTokenMessengerRemoved)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_RemoteTokenMessengerRemoved) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Domain != uint32(0) {
		value := protoreflect.ValueOfUint32(x.Domain)
		if !f(fd_RemoteTokenMessengerRemoved_domain, value) {
			return
		}
	}
	if len(x.RemoteTokenMessenger) != 0 {
		value := protoreflect.ValueOfBytes(x.RemoteTokenMessenger)
		if !f(fd_RemoteTokenMessengerRemoved_remote_token_messenger, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_RemoteTokenMessengerRemoved) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.domain":
		return x.Domain != uint32(0)
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.remote_token_messenger":
		return len(x.RemoteTokenMessenger) != 0
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerRemoved"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerRemoved does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemoteTokenMessengerRemoved) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.domain":
		x.Domain = uint32(0)
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.remote_token_messenger":
		x.RemoteTokenMessenger = nil
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerRemoved"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerRemoved does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_RemoteTokenMessengerRemoved) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.domain":
		value := x.Domain
		return protoreflect.ValueOfUint32(value)
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.remote_token_messenger":
		value := x.RemoteTokenMessenger
		return protoreflect.ValueOfBytes(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerRemoved"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerRemoved does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemoteTokenMessengerRemoved) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.domain":
		x.Domain = uint32(value.Uint())
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.remote_token_messenger":
		x.RemoteTokenMessenger = value.Bytes()
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerRemoved"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerRemoved does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemoteTokenMessengerRemoved) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.domain":
		panic(fmt.Errorf("field domain of message circle.cctp.v1.RemoteTokenMessengerRemoved is not mutable"))
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.remote_token_messenger":
		panic(fmt.Errorf("field remote_token_messenger of message circle.cctp.v1.RemoteTokenMessengerRemoved is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerRemoved"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerRemoved does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_RemoteTokenMessengerRemoved) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.domain":
		return protoreflect.ValueOfUint32(uint32(0))
	case "circle.cctp.v1.RemoteTokenMessengerRemoved.remote_token_messenger":
		return protoreflect.ValueOfBytes(nil)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.RemoteTokenMessengerRemoved"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.RemoteTokenMessengerRemoved does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_RemoteTokenMessengerRemoved) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.RemoteTokenMessengerRemoved", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_RemoteTokenMessengerRemoved) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_RemoteTokenMessengerRemoved) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_RemoteTokenMessengerRemoved) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_RemoteTokenMessengerRemoved) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*RemoteTokenMessengerRemoved)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		if x.Domain != 0 {
			n += 1 + runtime.Sov(uint64(x.Domain))
		}
		l = len(x.RemoteTokenMessenger)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*RemoteTokenMessengerRemoved)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.RemoteTokenMessenger) > 0 {
			i -= len(x.RemoteTokenMessenger)
			copy(dAtA[i:], x.RemoteTokenMessenger)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.RemoteTokenMessenger)))
			i--
			dAtA[i] = 0x12
		}
		if x.Domain != 0 {
			i = runtime.EncodeVarint(dAtA, i, uint64(x.Domain))
			i--
			dAtA[i] = 0x8
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*RemoteTokenMessengerRemoved)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: RemoteTokenMessengerRemoved: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: RemoteTokenMessengerRemoved: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
				}
				x.Domain = 0
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					x.Domain |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field RemoteTokenMessenger", wireType)
				}
				var byteLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					byteLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if byteLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + byteLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.RemoteTokenMessenger = append(x.RemoteTokenMessenger[:0], dAtA[iNdEx:postIndex]...)
				if x.RemoteTokenMessenger == nil {
					x.RemoteTokenMessenger = []byte{}
				}
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

var (
	md_SetBurnLimitPerMessage                        protoreflect.MessageDescriptor
	fd_SetBurnLimitPerMessage_token                  protoreflect.FieldDescriptor
	fd_SetBurnLimitPerMessage_burn_limit_per_message protoreflect.FieldDescriptor
)

func init() {
	file_circle_cctp_v1_events_proto_init()
	md_SetBurnLimitPerMessage = File_circle_cctp_v1_events_proto.Messages().ByName("SetBurnLimitPerMessage")
	fd_SetBurnLimitPerMessage_token = md_SetBurnLimitPerMessage.Fields().ByName("token")
	fd_SetBurnLimitPerMessage_burn_limit_per_message = md_SetBurnLimitPerMessage.Fields().ByName("burn_limit_per_message")
}

var _ protoreflect.Message = (*fastReflection_SetBurnLimitPerMessage)(nil)

type fastReflection_SetBurnLimitPerMessage SetBurnLimitPerMessage

func (x *SetBurnLimitPerMessage) ProtoReflect() protoreflect.Message {
	return (*fastReflection_SetBurnLimitPerMessage)(x)
}

func (x *SetBurnLimitPerMessage) slowProtoReflect() protoreflect.Message {
	mi := &file_circle_cctp_v1_events_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

var _fastReflection_SetBurnLimitPerMessage_messageType fastReflection_SetBurnLimitPerMessage_messageType
var _ protoreflect.MessageType = fastReflection_SetBurnLimitPerMessage_messageType{}

type fastReflection_SetBurnLimitPerMessage_messageType struct{}

func (x fastReflection_SetBurnLimitPerMessage_messageType) Zero() protoreflect.Message {
	return (*fastReflection_SetBurnLimitPerMessage)(nil)
}
func (x fastReflection_SetBurnLimitPerMessage_messageType) New() protoreflect.Message {
	return new(fastReflection_SetBurnLimitPerMessage)
}
func (x fastReflection_SetBurnLimitPerMessage_messageType) Descriptor() protoreflect.MessageDescriptor {
	return md_SetBurnLimitPerMessage
}

// Descriptor returns message descriptor, which contains only the protobuf
// type information for the message.
func (x *fastReflection_SetBurnLimitPerMessage) Descriptor() protoreflect.MessageDescriptor {
	return md_SetBurnLimitPerMessage
}

// Type returns the message type, which encapsulates both Go and protobuf
// type information. If the Go type information is not needed,
// it is recommended that the message descriptor be used instead.
func (x *fastReflection_SetBurnLimitPerMessage) Type() protoreflect.MessageType {
	return _fastReflection_SetBurnLimitPerMessage_messageType
}

// New returns a newly allocated and mutable empty message.
func (x *fastReflection_SetBurnLimitPerMessage) New() protoreflect.Message {
	return new(fastReflection_SetBurnLimitPerMessage)
}

// Interface unwraps the message reflection interface and
// returns the underlying ProtoMessage interface.
func (x *fastReflection_SetBurnLimitPerMessage) Interface() protoreflect.ProtoMessage {
	return (*SetBurnLimitPerMessage)(x)
}

// Range iterates over every populated field in an undefined order,
// calling f for each field descriptor and value encountered.
// Range returns immediately if f returns false.
// While iterating, mutating operations may only be performed
// on the current field descriptor.
func (x *fastReflection_SetBurnLimitPerMessage) Range(f func(protoreflect.FieldDescriptor, protoreflect.Value) bool) {
	if x.Token != "" {
		value := protoreflect.ValueOfString(x.Token)
		if !f(fd_SetBurnLimitPerMessage_token, value) {
			return
		}
	}
	if x.BurnLimitPerMessage != "" {
		value := protoreflect.ValueOfString(x.BurnLimitPerMessage)
		if !f(fd_SetBurnLimitPerMessage_burn_limit_per_message, value) {
			return
		}
	}
}

// Has reports whether a field is populated.
//
// Some fields have the property of nullability where it is possible to
// distinguish between the default value of a field and whether the field
// was explicitly populated with the default value. Singular message fields,
// member fields of a oneof, and proto2 scalar fields are nullable. Such
// fields are populated only if explicitly set.
//
// In other cases (aside from the nullable cases above),
// a proto3 scalar field is populated if it contains a non-zero value, and
// a repeated field is populated if it is non-empty.
func (x *fastReflection_SetBurnLimitPerMessage) Has(fd protoreflect.FieldDescriptor) bool {
	switch fd.FullName() {
	case "circle.cctp.v1.SetBurnLimitPerMessage.token":
		return x.Token != ""
	case "circle.cctp.v1.SetBurnLimitPerMessage.burn_limit_per_message":
		return x.BurnLimitPerMessage != ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SetBurnLimitPerMessage"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SetBurnLimitPerMessage does not contain field %s", fd.FullName()))
	}
}

// Clear clears the field such that a subsequent Has call reports false.
//
// Clearing an extension field clears both the extension type and value
// associated with the given field number.
//
// Clear is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SetBurnLimitPerMessage) Clear(fd protoreflect.FieldDescriptor) {
	switch fd.FullName() {
	case "circle.cctp.v1.SetBurnLimitPerMessage.token":
		x.Token = ""
	case "circle.cctp.v1.SetBurnLimitPerMessage.burn_limit_per_message":
		x.BurnLimitPerMessage = ""
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SetBurnLimitPerMessage"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SetBurnLimitPerMessage does not contain field %s", fd.FullName()))
	}
}

// Get retrieves the value for a field.
//
// For unpopulated scalars, it returns the default value, where
// the default value of a bytes scalar is guaranteed to be a copy.
// For unpopulated composite types, it returns an empty, read-only view
// of the value; to obtain a mutable reference, use Mutable.
func (x *fastReflection_SetBurnLimitPerMessage) Get(descriptor protoreflect.FieldDescriptor) protoreflect.Value {
	switch descriptor.FullName() {
	case "circle.cctp.v1.SetBurnLimitPerMessage.token":
		value := x.Token
		return protoreflect.ValueOfString(value)
	case "circle.cctp.v1.SetBurnLimitPerMessage.burn_limit_per_message":
		value := x.BurnLimitPerMessage
		return protoreflect.ValueOfString(value)
	default:
		if descriptor.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SetBurnLimitPerMessage"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SetBurnLimitPerMessage does not contain field %s", descriptor.FullName()))
	}
}

// Set stores the value for a field.
//
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType.
// When setting a composite type, it is unspecified whether the stored value
// aliases the source's memory in any way. If the composite value is an
// empty, read-only value, then it panics.
//
// Set is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SetBurnLimitPerMessage) Set(fd protoreflect.FieldDescriptor, value protoreflect.Value) {
	switch fd.FullName() {
	case "circle.cctp.v1.SetBurnLimitPerMessage.token":
		x.Token = value.Interface().(string)
	case "circle.cctp.v1.SetBurnLimitPerMessage.burn_limit_per_message":
		x.BurnLimitPerMessage = value.Interface().(string)
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SetBurnLimitPerMessage"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SetBurnLimitPerMessage does not contain field %s", fd.FullName()))
	}
}

// Mutable returns a mutable reference to a composite type.
//
// If the field is unpopulated, it may allocate a composite value.
// For a field belonging to a oneof, it implicitly clears any other field
// that may be currently set within the same oneof.
// For extension fields, it implicitly stores the provided ExtensionType
// if not already stored.
// It panics if the field does not contain a composite type.
//
// Mutable is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SetBurnLimitPerMessage) Mutable(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.SetBurnLimitPerMessage.token":
		panic(fmt.Errorf("field token of message circle.cctp.v1.SetBurnLimitPerMessage is not mutable"))
	case "circle.cctp.v1.SetBurnLimitPerMessage.burn_limit_per_message":
		panic(fmt.Errorf("field burn_limit_per_message of message circle.cctp.v1.SetBurnLimitPerMessage is not mutable"))
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SetBurnLimitPerMessage"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SetBurnLimitPerMessage does not contain field %s", fd.FullName()))
	}
}

// NewField returns a new value that is assignable to the field
// for the given descriptor. For scalars, this returns the default value.
// For lists, maps, and messages, this returns a new, empty, mutable value.
func (x *fastReflection_SetBurnLimitPerMessage) NewField(fd protoreflect.FieldDescriptor) protoreflect.Value {
	switch fd.FullName() {
	case "circle.cctp.v1.SetBurnLimitPerMessage.token":
		return protoreflect.ValueOfString("")
	case "circle.cctp.v1.SetBurnLimitPerMessage.burn_limit_per_message":
		return protoreflect.ValueOfString("")
	default:
		if fd.IsExtension() {
			panic(fmt.Errorf("proto3 declared messages do not support extensions: circle.cctp.v1.SetBurnLimitPerMessage"))
		}
		panic(fmt.Errorf("message circle.cctp.v1.SetBurnLimitPerMessage does not contain field %s", fd.FullName()))
	}
}

// WhichOneof reports which field within the oneof is populated,
// returning nil if none are populated.
// It panics if the oneof descriptor does not belong to this message.
func (x *fastReflection_SetBurnLimitPerMessage) WhichOneof(d protoreflect.OneofDescriptor) protoreflect.FieldDescriptor {
	switch d.FullName() {
	default:
		panic(fmt.Errorf("%s is not a oneof field in circle.cctp.v1.SetBurnLimitPerMessage", d.FullName()))
	}
	panic("unreachable")
}

// GetUnknown retrieves the entire list of unknown fields.
// The caller may only mutate the contents of the RawFields
// if the mutated bytes are stored back into the message with SetUnknown.
func (x *fastReflection_SetBurnLimitPerMessage) GetUnknown() protoreflect.RawFields {
	return x.unknownFields
}

// SetUnknown stores an entire list of unknown fields.
// The raw fields must be syntactically valid according to the wire format.
// An implementation may panic if this is not the case.
// Once stored, the caller must not mutate the content of the RawFields.
// An empty RawFields may be passed to clear the fields.
//
// SetUnknown is a mutating operation and unsafe for concurrent use.
func (x *fastReflection_SetBurnLimitPerMessage) SetUnknown(fields protoreflect.RawFields) {
	x.unknownFields = fields
}

// IsValid reports whether the message is valid.
//
// An invalid message is an empty, read-only value.
//
// An invalid message often corresponds to a nil pointer of the concrete
// message type, but the details are implementation dependent.
// Validity is not part of the protobuf data model, and may not
// be preserved in marshaling or other operations.
func (x *fastReflection_SetBurnLimitPerMessage) IsValid() bool {
	return x != nil
}

// ProtoMethods returns optional fastReflectionFeature-path implementations of various operations.
// This method may return nil.
//
// The returned methods type is identical to
// "google.golang.org/protobuf/runtime/protoiface".Methods.
// Consult the protoiface package documentation for details.
func (x *fastReflection_SetBurnLimitPerMessage) ProtoMethods() *protoiface.Methods {
	size := func(input protoiface.SizeInput) protoiface.SizeOutput {
		x := input.Message.Interface().(*SetBurnLimitPerMessage)
		if x == nil {
			return protoiface.SizeOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Size:              0,
			}
		}
		options := runtime.SizeInputToOptions(input)
		_ = options
		var n int
		var l int
		_ = l
		l = len(x.Token)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		l = len(x.BurnLimitPerMessage)
		if l > 0 {
			n += 1 + l + runtime.Sov(uint64(l))
		}
		if x.unknownFields != nil {
			n += len(x.unknownFields)
		}
		return protoiface.SizeOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Size:              n,
		}
	}

	marshal := func(input protoiface.MarshalInput) (protoiface.MarshalOutput, error) {
		x := input.Message.Interface().(*SetBurnLimitPerMessage)
		if x == nil {
			return protoiface.MarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Buf:               input.Buf,
			}, nil
		}
		options := runtime.MarshalInputToOptions(input)
		_ = options
		size := options.Size(x)
		dAtA := make([]byte, size)
		i := len(dAtA)
		_ = i
		var l int
		_ = l
		if x.unknownFields != nil {
			i -= len(x.unknownFields)
			copy(dAtA[i:], x.unknownFields)
		}
		if len(x.BurnLimitPerMessage) > 0 {
			i -= len(x.BurnLimitPerMessage)
			copy(dAtA[i:], x.BurnLimitPerMessage)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.BurnLimitPerMessage)))
			i--
			dAtA[i] = 0x12
		}
		if len(x.Token) > 0 {
			i -= len(x.Token)
			copy(dAtA[i:], x.Token)
			i = runtime.EncodeVarint(dAtA, i, uint64(len(x.Token)))
			i--
			dAtA[i] = 0xa
		}
		if input.Buf != nil {
			input.Buf = append(input.Buf, dAtA...)
		} else {
			input.Buf = dAtA
		}
		return protoiface.MarshalOutput{
			NoUnkeyedLiterals: input.NoUnkeyedLiterals,
			Buf:               input.Buf,
		}, nil
	}
	unmarshal := func(input protoiface.UnmarshalInput) (protoiface.UnmarshalOutput, error) {
		x := input.Message.Interface().(*SetBurnLimitPerMessage)
		if x == nil {
			return protoiface.UnmarshalOutput{
				NoUnkeyedLiterals: input.NoUnkeyedLiterals,
				Flags:             input.Flags,
			}, nil
		}
		options := runtime.UnmarshalInputToOptions(input)
		_ = options
		dAtA := input.Buf
		l := len(dAtA)
		iNdEx := 0
		for iNdEx < l {
			preIndex := iNdEx
			var wire uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
				}
				if iNdEx >= l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				wire |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			fieldNum := int32(wire >> 3)
			wireType := int(wire & 0x7)
			if wireType == 4 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SetBurnLimitPerMessage: wiretype end group for non-group")
			}
			if fieldNum <= 0 {
				return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: SetBurnLimitPerMessage: illegal tag %d (wire type %d)", fieldNum, wire)
			}
			switch fieldNum {
			case 1:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.Token = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			case 2:
				if wireType != 2 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, fmt.Errorf("proto: wrong wireType = %d for field BurnLimitPerMessage", wireType)
				}
				var stringLen uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrIntOverflow
					}
					if iNdEx >= l {
						return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLen |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLen := int(stringLen)
				if intStringLen < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				postIndex := iNdEx + intStringLen
				if postIndex < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if postIndex > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				x.BurnLimitPerMessage = string(dAtA[iNdEx:postIndex])
				iNdEx = postIndex
			default:
				iNdEx = preIndex
				skippy, err := runtime.Skip(dAtA[iNdEx:])
				if err != nil {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, err
				}
				if (skippy < 0) || (iNdEx+skippy) < 0 {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, runtime.ErrInvalidLength
				}
				if (iNdEx + skippy) > l {
					return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
				}
				if !options.DiscardUnknown {
					x.unknownFields = append(x.unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				}
				iNdEx += skippy
			}
		}

		if iNdEx > l {
			return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, io.ErrUnexpectedEOF
		}
		return protoiface.UnmarshalOutput{NoUnkeyedLiterals: input.NoUnkeyedLiterals, Flags: input.Flags}, nil
	}
	return &protoiface.Methods{
		NoUnkeyedLiterals: struct{}{},
		Flags:             protoiface.SupportMarshalDeterministic | protoiface.SupportUnmarshalDiscardUnknown,
		Size:              size,
		Marshal:           marshal,
		Unmarshal:         unmarshal,
		Merge:             nil,
		CheckInitialized:  nil,
	}
}

//
// Copyright (c) 2023,  Circle Internet Financial, LTD.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.27.0
// 	protoc        (unknown)
// source: circle/cctp/v1/events.proto

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// Emitted when an attester is enabled
// @param attester newly enabled attester
type AttesterEnabled struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Attester string `protobuf:"bytes,1,opt,name=attester,proto3" json:"attester,omitempty"`
}

func (x *AttesterEnabled) Reset() {
	*x = AttesterEnabled{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AttesterEnabled) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttesterEnabled) ProtoMessage() {}

// Deprecated: Use AttesterEnabled.ProtoReflect.Descriptor instead.
func (*AttesterEnabled) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{0}
}

func (x *AttesterEnabled) GetAttester() string {
	if x != nil {
		return x.Attester
	}
	return ""
}

// *
// Emitted when an attester is disabled
// @param attester newly disabled attester
type AttesterDisabled struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Attester string `protobuf:"bytes,1,opt,name=attester,proto3" json:"attester,omitempty"`
}

func (x *AttesterDisabled) Reset() {
	*x = AttesterDisabled{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AttesterDisabled) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttesterDisabled) ProtoMessage() {}

// Deprecated: Use AttesterDisabled.ProtoReflect.Descriptor instead.
func (*AttesterDisabled) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{1}
}

func (x *AttesterDisabled) GetAttester() string {
	if x != nil {
		return x.Attester
	}
	return ""
}

// *
// Emitted when threshold number of attestations (m in m/n multisig) is updated
// @param old_signature_threshold old signature threshold
// @param new_signature_threshold new signature threshold
type SignatureThresholdUpdated struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	OldSignatureThreshold uint64 `protobuf:"varint,1,opt,name=old_signature_threshold,json=oldSignatureThreshold,proto3" json:"old_signature_threshold,omitempty"`
	NewSignatureThreshold uint64 `protobuf:"varint,2,opt,name=new_signature_threshold,json=newSignatureThreshold,proto3" json:"new_signature_threshold,omitempty"`
}

func (x *SignatureThresholdUpdated) Reset() {
	*x = SignatureThresholdUpdated{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SignatureThresholdUpdated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignatureThresholdUpdated) ProtoMessage() {}

// Deprecated: Use SignatureThresholdUpdated.ProtoReflect.Descriptor instead.
func (*SignatureThresholdUpdated) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{2}
}

func (x *SignatureThresholdUpdated) GetOldSignatureThreshold() uint64 {
	if x != nil {
		return x.OldSignatureThreshold
	}
	return 0
}

func (x *SignatureThresholdUpdated) GetNewSignatureThreshold() uint64 {
	if x != nil {
		return x.NewSignatureThreshold
	}
	return 0
}

// *
// Emitted when owner address is updated
// @param previous_owner representing the address of the previous owner
// @param new_owner representing the address of the new owner
type OwnerUpdated struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PreviousOwner string `protobuf:"bytes,1,opt,name=previous_owner,json=previousOwner,proto3" json:"previous_owner,omitempty"`
	NewOwner      string `protobuf:"bytes,2,opt,name=new_owner,json=newOwner,proto3" json:"new_owner,omitempty"`
}

func (x *OwnerUpdated) Reset() {
	*x = OwnerUpdated{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OwnerUpdated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OwnerUpdated) ProtoMessage() {}

// Deprecated: Use OwnerUpdated.ProtoReflect.Descriptor instead.
func (*OwnerUpdated) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{3}
}

func (x *OwnerUpdated) GetPreviousOwner() string {
	if x != nil {
		return x.PreviousOwner
	}
	return ""
}

func (x *OwnerUpdated) GetNewOwner() string {
	if x != nil {
		return x.NewOwner
	}
	return ""
}

// *
// Emitted when starting the two stage transfer ownership process
// @param previousOwner representing the address of the previous owner
// @param newOwner representing the address of the new owner
type OwnershipTransferStarted struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PreviousOwner string `protobuf:"bytes,1,opt,name=previous_owner,json=previousOwner,proto3" json:"previous_owner,omitempty"`
	NewOwner      string `protobuf:"bytes,2,opt,name=new_owner,json=newOwner,proto3" json:"new_owner,omitempty"`
}

func (x *OwnershipTransferStarted) Reset() {
	*x = OwnershipTransferStarted{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *OwnershipTransferStarted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OwnershipTransferStarted) ProtoMessage() {}

// Deprecated: Use OwnershipTransferStarted.ProtoReflect.Descriptor instead.
func (*OwnershipTransferStarted) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{4}
}

func (x *OwnershipTransferStarted) GetPreviousOwner() string {
	if x != nil {
		return x.PreviousOwner
	}
	return ""
}

func (x *OwnershipTransferStarted) GetNewOwner() string {
	if x != nil {
		return x.NewOwner
	}
	return ""
}

// *
// Emitted when pauser address is updated
// @param previous_pauser representing the address of the previous pauser
// @param new_pauser representing the address of the new pauser
type PauserUpdated struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PreviousPauser string `protobuf:"bytes,1,opt,name=previous_pauser,json=previousPauser,proto3" json:"previous_pauser,omitempty"`
	NewPauser      string `protobuf:"bytes,2,opt,name=new_pauser,json=newPauser,proto3" json:"new_pauser,omitempty"`
}

func (x *PauserUpdated) Reset() {
	*x = PauserUpdated{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PauserUpdated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PauserUpdated) ProtoMessage() {}

// Deprecated: Use PauserUpdated.ProtoReflect.Descriptor instead.
func (*PauserUpdated) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{5}
}

func (x *PauserUpdated) GetPreviousPauser() string {
	if x != nil {
		return x.PreviousPauser
	}
	return ""
}

func (x *PauserUpdated) GetNewPauser() string {
	if x != nil {
		return x.NewPauser
	}
	return ""
}

// *
// Emitted when attester manager address is updated
// @param previous_attester_manager representing the address of the previous
// attester manager
// @param new_attester_manager representing the address of the new attester
// manager
type AttesterManagerUpdated struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PreviousAttesterManager string `protobuf:"bytes,1,opt,name=previous_attester_manager,json=previousAttesterManager,proto3" json:"previous_attester_manager,omitempty"`
	NewAttesterManager      string `protobuf:"bytes,2,opt,name=new_attester_manager,json=newAttesterManager,proto3" json:"new_attester_manager,omitempty"`
}

func (x *AttesterManagerUpdated) Reset() {
	*x = AttesterManagerUpdated{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AttesterManagerUpdated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttesterManagerUpdated) ProtoMessage() {}

// Deprecated: Use AttesterManagerUpdated.ProtoReflect.Descriptor instead.
func (*AttesterManagerUpdated) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{6}
}

func (x *AttesterManagerUpdated) GetPreviousAttesterManager() string {
	if x != nil {
		return x.PreviousAttesterManager
	}
	return ""
}

func (x *AttesterManagerUpdated) GetNewAttesterManager() string {
	if x != nil {
		return x.NewAttesterManager
	}
	return ""
}

// *
// Emitted when token controller address is updated
// @param previous_token_controller representing the address of the previous
// token controller
// @param new_token_controller representing the address of the new token
// controller
type TokenControllerUpdated struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PreviousTokenController string `protobuf:"bytes,1,opt,name=previous_token_controller,json=previousTokenController,proto3" json:"previous_token_controller,omitempty"`
	NewTokenController      string `protobuf:"bytes,2,opt,name=new_token_controller,json=newTokenController,proto3" json:"new_token_controller,omitempty"`
}

func (x *TokenControllerUpdated) Reset() {
	*x = TokenControllerUpdated{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TokenControllerUpdated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenControllerUpdated) ProtoMessage() {}

// Deprecated: Use TokenControllerUpdated.ProtoReflect.Descriptor instead.
func (*TokenControllerUpdated) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{7}
}

func (x *TokenControllerUpdated) GetPreviousTokenController() string {
	if x != nil {
		return x.PreviousTokenController
	}
	return ""
}

func (x *TokenControllerUpdated) GetNewTokenController() string {
	if x != nil {
		return x.NewTokenController
	}
	return ""
}

// *
// Emitted when burning and minting tokens is paused
type BurningAndMintingPausedEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *BurningAndMintingPausedEvent) Reset() {
	*x = BurningAndMintingPausedEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BurningAndMintingPausedEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BurningAndMintingPausedEvent) ProtoMessage() {}

// Deprecated: Use BurningAndMintingPausedEvent.ProtoReflect.Descriptor instead.
func (*BurningAndMintingPausedEvent) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{8}
}

// *
// Emitted when burning and minting tokens is unpaused
type BurningAndMintingUnpausedEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *BurningAndMintingUnpausedEvent) Reset() {
	*x = BurningAndMintingUnpausedEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BurningAndMintingUnpausedEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BurningAndMintingUnpausedEvent) ProtoMessage() {}

// Deprecated: Use BurningAndMintingUnpausedEvent.ProtoReflect.Descriptor instead.
func (*BurningAndMintingUnpausedEvent) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{9}
}

// *
// Emitted when sending and receiving messages is paused
type SendingAndReceivingPausedEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SendingAndReceivingPausedEvent) Reset() {
	*x = SendingAndReceivingPausedEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SendingAndReceivingPausedEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendingAndReceivingPausedEvent) ProtoMessage() {}

// Deprecated: Use SendingAndReceivingPausedEvent.ProtoReflect.Descriptor instead.
func (*SendingAndReceivingPausedEvent) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{10}
}

// *
// Emitted when sending and receiving messages is paused
type SendingAndReceivingUnpausedEvent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SendingAndReceivingUnpausedEvent) Reset() {
	*x = SendingAndReceivingUnpausedEvent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SendingAndReceivingUnpausedEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SendingAndReceivingUnpausedEvent) ProtoMessage() {}

// Deprecated: Use SendingAndReceivingUnpausedEvent.ProtoReflect.Descriptor instead.
func (*SendingAndReceivingUnpausedEvent) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{11}
}

// *
// Emitted when a DepositForBurn message is sent
// @param nonce unique nonce reserved by message
// @param burn_token address of token burnt on source domain
// @param amount deposit amount
// @param depositor address where deposit is transferred from
// @param mint_recipient address receiving minted tokens on destination domain
// as bytes32
// @param destination_domain destination domain
// @param destination_token_messenger address of TokenMessenger on destination
// domain as bytes32
// @param destination_caller authorized caller as bytes32 of receiveMessage() on
// destination domain, if not equal to bytes32(0). If equal to bytes32(0), any
// address can call receiveMessage().
type DepositForBurn struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Nonce                     uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	BurnToken                 string `protobuf:"bytes,2,opt,name=burn_token,json=burnToken,proto3" json:"burn_token,omitempty"`
	Amount                    string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Depositor                 string `protobuf:"bytes,4,opt,name=depositor,proto3" json:"depositor,omitempty"`
	MintRecipient             []byte `protobuf:"bytes,5,opt,name=mint_recipient,json=mintRecipient,proto3" json:"mint_recipient,omitempty"`
	DestinationDomain         uint32 `protobuf:"varint,6,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	DestinationTokenMessenger []byte `protobuf:"bytes,7,opt,name=destination_token_messenger,json=destinationTokenMessenger,proto3" json:"destination_token_messenger,omitempty"`
	DestinationCaller         []byte `protobuf:"bytes,8,opt,name=destination_caller,json=destinationCaller,proto3" json:"destination_caller,omitempty"`
}

func (x *DepositForBurn) Reset() {
	*x = DepositForBurn{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DepositForBurn) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositForBurn) ProtoMessage() {}

// Deprecated: Use DepositForBurn.ProtoReflect.Descriptor instead.
func (*DepositForBurn) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{12}
}

func (x *DepositForBurn) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *DepositForBurn) GetBurnToken() string {
	if x != nil {
		return x.BurnToken
	}
	return ""
}

func (x *DepositForBurn) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *DepositForBurn) GetDepositor() string {
	if x != nil {
		return x.Depositor
	}
	return ""
}

func (x *DepositForBurn) GetMintRecipient() []byte {
	if x != nil {
		return x.MintRecipient
	}
	return nil
}

func (x *DepositForBurn) GetDestinationDomain() uint32 {
	if x != nil {
		return x.DestinationDomain
	}
	return 0
}

func (x *DepositForBurn) GetDestinationTokenMessenger() []byte {
	if x != nil {
		return x.DestinationTokenMessenger
	}
	return nil
}

func (x *DepositForBurn) GetDestinationCaller() []byte {
	if x != nil {
		return x.DestinationCaller
	}
	return nil
}

// *
// Emitted when tokens are minted
// @param mint_recipient recipient address of minted tokens
// @param amount amount of minted tokens
// @param mint_token contract address of minted token
type MintAndWithdraw struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MintRecipient []byte `protobuf:"bytes,1,opt,name=mint_recipient,json=mintRecipient,proto3" json:"mint_recipient,omitempty"`
	Amount        string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	MintToken     string `protobuf:"bytes,3,opt,name=mint_token,json=mintToken,proto3" json:"mint_token,omitempty"`
}

func (x *MintAndWithdraw) Reset() {
	*x = MintAndWithdraw{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MintAndWithdraw) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MintAndWithdraw) ProtoMessage() {}

// Deprecated: Use MintAndWithdraw.ProtoReflect.Descriptor instead.
func (*MintAndWithdraw) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{13}
}

func (x *MintAndWithdraw) GetMintRecipient() []byte {
	if x != nil {
		return x.MintRecipient
	}
	return nil
}

func (x *MintAndWithdraw) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

func (x *MintAndWithdraw) GetMintToken() string {
	if x != nil {
		return x.MintToken
	}
	return ""
}

// *
// Emitted when a token pair is linked
// @param local_token local token to support
// @param remote_domain remote domain
// @param remote_token token on `remoteDomain` corresponding to `localToken`
type TokenPairLinked struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	LocalToken   string `protobuf:"bytes,1,opt,name=local_token,json=localToken,proto3" json:"local_token,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remote_domain,json=remoteDomain,proto3" json:"remote_domain,omitempty"`
	RemoteToken  []byte `protobuf:"bytes,3,opt,name=remote_token,json=remoteToken,proto3" json:"remote_token,omitempty"`
}

func (x *TokenPairLinked) Reset() {
	*x = TokenPairLinked{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TokenPairLinked) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenPairLinked) ProtoMessage() {}

// Deprecated: Use TokenPairLinked.ProtoReflect.Descriptor instead.
func (*TokenPairLinked) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{14}
}

func (x *TokenPairLinked) GetLocalToken() string {
	if x != nil {
		return x.LocalToken
	}
	return ""
}

func (x *TokenPairLinked) GetRemoteDomain() uint32 {
	if x != nil {
		return x.RemoteDomain
	}
	return 0
}

func (x *TokenPairLinked) GetRemoteToken() []byte {
	if x != nil {
		return x.RemoteToken
	}
	return nil
}

// *
// Emitted when a token pair is unlinked
// @param local_token local token address
// @param remote_domain remote domain
// @param remote_token token on `remoteDomain` unlinked from `localToken`
type TokenPairUnlinked struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	LocalToken   string `protobuf:"bytes,1,opt,name=local_token,json=localToken,proto3" json:"local_token,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remote_domain,json=remoteDomain,proto3" json:"remote_domain,omitempty"`
	RemoteToken  []byte `protobuf:"bytes,3,opt,name=remote_token,json=remoteToken,proto3" json:"remote_token,omitempty"`
}

func (x *TokenPairUnlinked) Reset() {
	*x = TokenPairUnlinked{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TokenPairUnlinked) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenPairUnlinked) ProtoMessage() {}

// Deprecated: Use TokenPairUnlinked.ProtoReflect.Descriptor instead.
func (*TokenPairUnlinked) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{15}
}

func (x *TokenPairUnlinked) GetLocalToken() string {
	if x != nil {
		return x.LocalToken
	}
	return ""
}

func (x *TokenPairUnlinked) GetRemoteDomain() uint32 {
	if x != nil {
		return x.RemoteDomain
	}
	return 0
}

func (x *TokenPairUnlinked) GetRemoteToken() []byte {
	if x != nil {
		return x.RemoteToken
	}
	return nil
}

// *
// Emitted when a new message is dispatched
// @param message Raw bytes of message
type MessageSent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Message []byte `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *MessageSent) Reset() {
	*x = MessageSent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MessageSent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageSent) ProtoMessage() {}

// Deprecated: Use MessageSent.ProtoReflect.Descriptor instead.
func (*MessageSent) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{16}
}

func (x *MessageSent) GetMessage() []byte {
	if x != nil {
		return x.Message
	}
	return nil
}

// *
// Emitted when a new message is received
// @param caller caller (msg.sender) on destination domain
// @param source_domain the source domain this message originated from
// @param nonce the nonce unique to this message
// @param sender the sender of this message
// @param message_body message body bytes
type MessageReceived struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Caller       string `protobuf:"bytes,1,opt,name=caller,proto3" json:"caller,omitempty"`
	SourceDomain uint32 `protobuf:"varint,2,opt,name=source_domain,json=sourceDomain,proto3" json:"source_domain,omitempty"`
	Nonce        uint64 `protobuf:"varint,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Sender       []byte `protobuf:"bytes,4,opt,name=sender,proto3" json:"sender,omitempty"`
	MessageBody  []byte `protobuf:"bytes,5,opt,name=message_body,json=messageBody,proto3" json:"message_body,omitempty"`
}

func (x *MessageReceived) Reset() {
	*x = MessageReceived{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MessageReceived) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MessageReceived) ProtoMessage() {}

// Deprecated: Use MessageReceived.ProtoReflect.Descriptor instead.
func (*MessageReceived) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{17}
}

func (x *MessageReceived) GetCaller() string {
	if x != nil {
		return x.Caller
	}
	return ""
}

func (x *MessageReceived) GetSourceDomain() uint32 {
	if x != nil {
		return x.SourceDomain
	}
	return 0
}

func (x *MessageReceived) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *MessageReceived) GetSender() []byte {
	if x != nil {
		return x.Sender
	}
	return nil
}

func (x *MessageReceived) GetMessageBody() []byte {
	if x != nil {
		return x.MessageBody
	}
	return nil
}

// *
// Emitted when max message body size is updated
// @param new_max_message_body_size new maximum message body size, in bytes
type MaxMessageBodySizeUpdated struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NewMaxMessageBodySize uint64 `protobuf:"varint,1,opt,name=new_max_message_body_size,json=newMaxMessageBodySize,proto3" json:"new_max_message_body_size,omitempty"`
}

func (x *MaxMessageBodySizeUpdated) Reset() {
	*x = MaxMessageBodySizeUpdated{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MaxMessageBodySizeUpdated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MaxMessageBodySizeUpdated) ProtoMessage() {}

// Deprecated: Use MaxMessageBodySizeUpdated.ProtoReflect.Descriptor instead.
func (*MaxMessageBodySizeUpdated) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{18}
}

func (x *MaxMessageBodySizeUpdated) GetNewMaxMessageBodySize() uint64 {
	if x != nil {
		return x.NewMaxMessageBodySize
	}
	return 0
}

// *
// Emitted when a RemoteTokenMessenger is added
// @param domain remote domain
// @param remote_token_messenger RemoteTokenMessenger on domain
type RemoteTokenMessengerAdded struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Domain               uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	RemoteTokenMessenger []byte `protobuf:"bytes,2,opt,name=remote_token_messenger,json=remoteTokenMessenger,proto3" json:"remote_token_messenger,omitempty"`
}

func (x *RemoteTokenMessengerAdded) Reset() {
	*x = RemoteTokenMessengerAdded{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoteTokenMessengerAdded) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteTokenMessengerAdded) ProtoMessage() {}

// Deprecated: Use RemoteTokenMessengerAdded.ProtoReflect.Descriptor instead.
func (*RemoteTokenMessengerAdded) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{19}
}

func (x *RemoteTokenMessengerAdded) GetDomain() uint32 {
	if x != nil {
		return x.Domain
	}
	return 0
}

func (x *RemoteTokenMessengerAdded) GetRemoteTokenMessenger() []byte {
	if x != nil {
		return x.RemoteTokenMessenger
	}
	return nil
}

// *
// Emitted when a RemoteTokenMessenger is removed
// @param domain remote domain
// @param remote_token_messenger RemoteTokenMessenger on domain
type RemoteTokenMessengerRemoved struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Domain               uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	RemoteTokenMessenger []byte `protobuf:"bytes,2,opt,name=remote_token_messenger,json=remoteTokenMessenger,proto3" json:"remote_token_messenger,omitempty"`
}

func (x *RemoteTokenMessengerRemoved) Reset() {
	*x = RemoteTokenMessengerRemoved{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RemoteTokenMessengerRemoved) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteTokenMessengerRemoved) ProtoMessage() {}

// Deprecated: Use RemoteTokenMessengerRemoved.ProtoReflect.Descriptor instead.
func (*RemoteTokenMessengerRemoved) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{20}
}

func (x *RemoteTokenMessengerRemoved) GetDomain() uint32 {
	if x != nil {
		return x.Domain
	}
	return 0
}

func (x *RemoteTokenMessengerRemoved) GetRemoteTokenMessenger() []byte {
	if x != nil {
		return x.RemoteTokenMessenger
	}
	return nil
}

// *
// Emitted when max burn amount per message is updated
// @param local_token
// @param old_amount old max burn amount
// @param new_amount new max burn amount
type SetBurnLimitPerMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Token               string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	BurnLimitPerMessage string `protobuf:"bytes,2,opt,name=burn_limit_per_message,json=burnLimitPerMessage,proto3" json:"burn_limit_per_message,omitempty"`
}

func (x *SetBurnLimitPerMessage) Reset() {
	*x = SetBurnLimitPerMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_circle_cctp_v1_events_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SetBurnLimitPerMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetBurnLimitPerMessage) ProtoMessage() {}

// Deprecated: Use SetBurnLimitPerMessage.ProtoReflect.Descriptor instead.
func (*SetBurnLimitPerMessage) Descriptor() ([]byte, []int) {
	return file_circle_cctp_v1_events_proto_rawDescGZIP(), []int{21}
}

func (x *SetBurnLimitPerMessage) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *SetBurnLimitPerMessage) GetBurnLimitPerMessage() string {
	if x != nil {
		return x.BurnLimitPerMessage
	}
	return ""
}

var File_circle_cctp_v1_events_proto protoreflect.FileDescriptor

var file_circle_cctp_v1_events_proto_rawDesc = []byte{
	0x0a, 0x1b, 0x63, 0x69, 0x72, 0x63, 0x6c, 0x65, 0x2f, 0x63, 0x63, 0x74, 0x70, 0x2f, 0x76, 0x31,
	0x2f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0e, 0x63,
	0x69, 0x72, 0x63, 0x6c, 0x65, 0x2e, 0x63, 0x63, 0x74, 0x70, 0x2e, 0x76, 0x31, 0x1a, 0x14, 0x67,
	0x6f, 0x67, 0x6f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x6f, 0x67, 0x6f, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0x2d, 0x0a, 0x0f, 0x41, 0x74, 0x74, 0x65, 0x73, 0x74, 0x65, 0x72, 0x45,
	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74,
	0x65, 0x72, 0x22, 0x2e, 0x0a, 0x10, 0x41, 0x74, 0x74, 0x65, 0x73, 0x74, 0x65, 0x72, 0x44, 0x69,
	0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74,
	0x65, 0x72, 0x22, 0x8b, 0x01, 0x0a, 0x19, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65,
	0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64,
	0x12, 0x36, 0x0a, 0x17, 0x6f, 0x6c, 0x64, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72,
	0x65, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x04, 0x52, 0x15, 0x6f, 0x6c, 0x64, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54,
	0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x12, 0x36, 0x0a, 0x17, 0x6e, 0x65, 0x77, 0x5f,
	0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68,
	0x6f, 0x6c, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x52, 0x15, 0x6e, 0x65, 0x77, 0x53, 0x69,
	0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64,
	0x22, 0x52, 0x0a, 0x0c, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64,
	0x12, 0x25, 0x0a, 0x0e, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x5f, 0x6f, 0x77, 0x6e,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f,
	0x75, 0x73, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x6e, 0x65, 0x77, 0x5f, 0x6f,
	0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6e, 0x65, 0x77, 0x4f,
	0x77, 0x6e, 0x65, 0x72, 0x22, 0x5e, 0x0a, 0x18, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69,
	0x70, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x53, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64,
	0x12, 0x25, 0x0a, 0x0e, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x5f, 0x6f, 0x77, 0x6e,
	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f,
	0x75, 0x73, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x1b, 0x0a, 0x09, 0x6e, 0x65, 0x77, 0x5f, 0x6f,
	0x77, 0x6e, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6e, 0x65, 0x77, 0x4f,
	0x77, 0x6e, 0x65, 0x72, 0x22, 0x57, 0x0a, 0x0d, 0x50, 0x61, 0x75, 0x73, 0x65, 0x72, 0x55, 0x70,
	0x64, 0x61, 0x74, 0x65, 0x64, 0x12, 0x27, 0x0a, 0x0f, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75,
	0x73, 0x5f, 0x70, 0x61, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e,
	0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x50, 0x61, 0x75, 0x73, 0x65, 0x72, 0x12, 0x1d,
	0x0a, 0x0a, 0x6e, 0x65, 0x77, 0x5f, 0x70, 0x61, 0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x09, 0x6e, 0x65, 0x77, 0x50, 0x61, 0x75, 0x73, 0x65, 0x72, 0x22, 0x86, 0x01,
	0x0a, 0x16, 0x41, 0x74, 0x74, 0x65, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x61, 0x6e, 0x61, 0x67, 0x65,
	0x72, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x12, 0x3a, 0x0a, 0x19, 0x70, 0x72, 0x65, 0x76,
	0x69, 0x6f, 0x75, 0x73, 0x5f, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x6d, 0x61,
	0x6e, 0x61, 0x67, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x17, 0x70, 0x72, 0x65,
	0x76, 0x69, 0x6f, 0x75, 0x73, 0x41, 0x74, 0x74, 0x65, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x61, 0x6e,
	0x61, 0x67, 0x65, 0x72, 0x12, 0x30, 0x0a, 0x14, 0x6e, 0x65, 0x77, 0x5f, 0x61, 0x74, 0x74, 0x65,
	0x73, 0x74, 0x65, 0x72, 0x5f, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x12, 0x6e, 0x65, 0x77, 0x41, 0x74, 0x74, 0x65, 0x73, 0x74, 0x65, 0x72, 0x4d,
	0x61, 0x6e, 0x61, 0x67, 0x65, 0x72, 0x22, 0x86, 0x01, 0x0a, 0x16, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
	0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x64, 0x12, 0x3a, 0x0a, 0x19, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x5f, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x17, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x54, 0x6f,
	0x6b, 0x65, 0x6e, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x12, 0x30, 0x0a,
	0x14, 0x6e, 0x65, 0x77, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x72,
	0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x6e, 0x65, 0x77,
	0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x6c, 0x65, 0x72, 0x22,
	0x1e, 0x0a, 0x1c, 0x42, 0x75, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x41, 0x6e, 0x64, 0x4d, 0x69, 0x6e,
	0x74, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x75, 0x73, 0x65, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x22,
	0x20, 0x0a, 0x1e, 0x42, 0x75, 0x72, 0x6e, 0x69, 0x6e, 0x67, 0x41, 0x6e, 0x64, 0x4d, 0x69, 0x6e,
	0x74, 0x69, 0x6e, 0x67, 0x55, 0x6e, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x22, 0x20, 0x0a, 0x1e, 0x53, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x41, 0x6e, 0x64, 0x52,
	0x65, 0x63, 0x65, 0x69, 0x76, 0x69, 0x6e, 0x67, 0x50, 0x61, 0x75, 0x73, 0x65, 0x64, 0x45, 0x76,
	0x65, 0x6e, 0x74, 0x22, 0x22, 0x0a, 0x20, 0x53, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x41, 0x6e,
	0x64, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x69, 0x6e, 0x67, 0x55, 0x6e, 0x70, 0x61, 0x75, 0x73,
	0x65, 0x64, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x22, 0xdf, 0x02, 0x0a, 0x0e, 0x44, 0x65, 0x70, 0x6f,
	0x73, 0x69, 0x74, 0x46, 0x6f, 0x72, 0x42, 0x75, 0x72, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x6e, 0x6f,
	0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x6e, 0x6f, 0x6e, 0x63, 0x65,
	0x12, 0x1d, 0x0a, 0x0a, 0x62, 0x75, 0x72, 0x6e, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x62, 0x75, 0x72, 0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
	0x35, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x06,
	0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x64, 0x65, 0x70, 0x6f, 0x73, 0x69,
	0x74, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x64, 0x65, 0x70, 0x6f, 0x73,
	0x69, 0x74, 0x6f, 0x72, 0x12, 0x25, 0x0a, 0x0e, 0x6d, 0x69, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x63,
	0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0d, 0x6d, 0x69,
	0x6e, 0x74, 0x52, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x2d, 0x0a, 0x12, 0x64,
	0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x64, 0x6f, 0x6d, 0x61, 0x69,
	0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x11, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x3e, 0x0a, 0x1b, 0x64, 0x65,
	0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f,
	0x6d, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x67, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x19, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x6b, 0x65,
	0x6e, 0x4d, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x67, 0x65, 0x72, 0x12, 0x2d, 0x0a, 0x12, 0x64, 0x65,
	0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x61, 0x6c, 0x6c, 0x65, 0x72,
	0x18, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x11, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x43, 0x61, 0x6c, 0x6c, 0x65, 0x72, 0x22, 0x8e, 0x01, 0x0a, 0x0f, 0x4d, 0x69,
	0x6e, 0x74, 0x41, 0x6e, 0x64, 0x57, 0x69, 0x74, 0x68, 0x64, 0x72, 0x61, 0x77, 0x12, 0x25, 0x0a,
	0x0e, 0x6d, 0x69, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65, 0x6e, 0x74, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0d, 0x6d, 0x69, 0x6e, 0x74, 0x52, 0x65, 0x63, 0x69, 0x70,
	0x69, 0x65, 0x6e, 0x74, 0x12, 0x35, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x42, 0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f,
	0x73, 0x6d, 0x6f, 0x73, 0x73, 0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e,
	0x49, 0x6e, 0x74, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x6d,
	0x69, 0x6e, 0x74, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x09, 0x6d, 0x69, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x7a, 0x0a, 0x0f, 0x54, 0x6f,
	0x6b, 0x65, 0x6e, 0x50, 0x61, 0x69, 0x72, 0x4c, 0x69, 0x6e, 0x6b, 0x65, 0x64, 0x12, 0x1f, 0x0a,
	0x0b, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x23,
	0x0a, 0x0d, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x44, 0x6f, 0x6d,
	0x61, 0x69, 0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f, 0x74, 0x6f,
	0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74,
	0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x7c, 0x0a, 0x11, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x50,
	0x61, 0x69, 0x72, 0x55, 0x6e, 0x6c, 0x69, 0x6e, 0x6b, 0x65, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x6c,
	0x6f, 0x63, 0x61, 0x6c, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x23, 0x0a, 0x0d,
	0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0c, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x44, 0x6f, 0x6d, 0x61, 0x69,
	0x6e, 0x12, 0x21, 0x0a, 0x0c, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0b, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x54,
	0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x27, 0x0a, 0x0b, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x53,
	0x65, 0x6e, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x22, 0x9f, 0x01,
	0x0a, 0x0f, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
	0x64, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x61, 0x6c, 0x6c, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x06, 0x63, 0x61, 0x6c, 0x6c, 0x65, 0x72, 0x12, 0x23, 0x0a, 0x0d, 0x73, 0x6f, 0x75,
	0x72, 0x63, 0x65, 0x5f, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0c, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x14,
	0x0a, 0x05, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x52, 0x05, 0x6e,
	0x6f, 0x6e, 0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x12, 0x21, 0x0a, 0x0c,
	0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x62, 0x6f, 0x64, 0x79, 0x18, 0x05, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x0b, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6f, 0x64, 0x79, 0x22,
	0x55, 0x0a, 0x19, 0x4d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6f, 0x64,
	0x79, 0x53, 0x69, 0x7a, 0x65, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x12, 0x38, 0x0a, 0x19,
	0x6e, 0x65, 0x77, 0x5f, 0x6d, 0x61, 0x78, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f,
	0x62, 0x6f, 0x64, 0x79, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52,
	0x15, 0x6e, 0x65, 0x77, 0x4d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x42, 0x6f,
	0x64, 0x79, 0x53, 0x69, 0x7a, 0x65, 0x22, 0x69, 0x0a, 0x19, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65,
	0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x67, 0x65, 0x72, 0x41, 0x64,
	0x64, 0x65, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x34, 0x0a, 0x16, 0x72,
	0x65, 0x6d, 0x6f, 0x74, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x6d, 0x65, 0x73, 0x73,
	0x65, 0x6e, 0x67, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x14, 0x72, 0x65, 0x6d,
	0x6f, 0x74, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x67, 0x65,
	0x72, 0x22, 0x6b, 0x0a, 0x1b, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e,
	0x4d, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x67, 0x65, 0x72, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64,
	0x12, 0x16, 0x0a, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x12, 0x34, 0x0a, 0x16, 0x72, 0x65, 0x6d, 0x6f,
	0x74, 0x65, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x67,
	0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x14, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65,
	0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x4d, 0x65, 0x73, 0x73, 0x65, 0x6e, 0x67, 0x65, 0x72, 0x22, 0x82,
	0x01, 0x0a, 0x16, 0x53, 0x65, 0x74, 0x42, 0x75, 0x72, 0x6e, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x50,
	0x65, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b,
	0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
	0x52, 0x0a, 0x16, 0x62, 0x75, 0x72, 0x6e, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f, 0x70, 0x65,
	0x72, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42,
	0x1d, 0xc8, 0xde, 0x1f, 0x00, 0xda, 0xde, 0x1f, 0x15, 0x63, 0x6f, 0x73, 0x6d, 0x6f, 0x73, 0x73,
	0x64, 0x6b, 0x2e, 0x69, 0x6f, 0x2f, 0x6d, 0x61, 0x74, 0x68, 0x2e, 0x49, 0x6e, 0x74, 0x52, 0x13,
	0x62, 0x75, 0x72, 0x6e, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x50, 0x65, 0x72, 0x4d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x42, 0xb6, 0x01, 0x0a, 0x12, 0x63, 0x6f, 0x6d, 0x2e, 0x63, 0x69, 0x72, 0x63,
	0x6c, 0x65, 0x2e, 0x63, 0x63, 0x74, 0x70, 0x2e, 0x76, 0x31, 0x42, 0x0b, 0x45, 0x76, 0x65, 0x6e,
	0x74, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x39, 0x67, 0x69, 0x74, 0x68, 0x75,
	0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x69, 0x72, 0x63, 0x6c, 0x65, 0x66, 0x69, 0x6e, 0x2f,
	0x6e, 0x6f, 0x62, 0x6c, 0x65, 0x2d, 0x63, 0x63, 0x74, 0x70, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x63,
	0x69, 0x72, 0x63, 0x6c, 0x65, 0x2f, 0x63, 0x63, 0x74, 0x70, 0x2f, 0x76, 0x31, 0x3b, 0x63, 0x63,
	0x74, 0x70, 0x76, 0x31, 0xa2, 0x02, 0x03, 0x43, 0x43, 0x58, 0xaa, 0x02, 0x0e, 0x43, 0x69, 0x72,
	0x63, 0x6c, 0x65, 0x2e, 0x43, 0x63, 0x74, 0x70, 0x2e, 0x56, 0x31, 0xca, 0x02, 0x0e, 0x43, 0x69,
	0x72, 0x63, 0x6c, 0x65, 0x5c, 0x43, 0x63, 0x74, 0x70, 0x5c, 0x56, 0x31, 0xe2, 0x02, 0x1a, 0x43,
	0x69, 0x72, 0x63, 0x6c, 0x65, 0x5c, 0x43, 0x63, 0x74, 0x70, 0x5c, 0x56, 0x31, 0x5c, 0x47, 0x50,
	0x42, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x10, 0x43, 0x69, 0x72, 0x63,
	0x6c, 0x65, 0x3a, 0x3a, 0x43, 0x63, 0x74, 0x70, 0x3a, 0x3a, 0x56, 0x31, 0x62, 0x06, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_circle_cctp_v1_events_proto_rawDescOnce sync.Once
	file_circle_cctp_v1_events_proto_rawDescData = file_circle_cctp_v1_events_proto_rawDesc
)

func file_circle_cctp_v1_events_proto_rawDescGZIP() []byte {
	file_circle_cctp_v1_events_proto_rawDescOnce.Do(func() {
		file_circle_cctp_v1_events_proto_rawDescData = protoimpl.X.CompressGZIP(file_circle_cctp_v1_events_proto_rawDescData)
	})
	return file_circle_cctp_v1_events_proto_rawDescData
}

var file_circle_cctp_v1_events_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_circle_cctp_v1_events_proto_goTypes = []interface{}{
	(*AttesterEnabled)(nil),                  // 0: circle.cctp.v1.AttesterEnabled
	(*AttesterDisabled)(nil),                 // 1: circle.cctp.v1.AttesterDisabled
	(*SignatureThresholdUpdated)(nil),        // 2: circle.cctp.v1.SignatureThresholdUpdated
	(*OwnerUpdated)(nil),                     // 3: circle.cctp.v1.OwnerUpdated
	(*OwnershipTransferStarted)(nil),         // 4: circle.cctp.v1.OwnershipTransferStarted
	(*PauserUpdated)(nil),                    // 5: circle.cctp.v1.PauserUpdated
	(*AttesterManagerUpdated)(nil),           // 6: circle.cctp.v1.AttesterManagerUpdated
	(*TokenControllerUpdated)(nil),           // 7: circle.cctp.v1.TokenControllerUpdated
	(*BurningAndMintingPausedEvent)(nil),     // 8: circle.cctp.v1.BurningAndMintingPausedEvent
	(*BurningAndMintingUnpausedEvent)(nil),   // 9: circle.cctp.v1.BurningAndMintingUnpausedEvent
	(*SendingAndReceivingPausedEvent)(nil),   // 10: circle.cctp.v1.SendingAndReceivingPausedEvent
	(*SendingAndReceivingUnpausedEvent)(nil), // 11: circle.cctp.v1.SendingAndReceivingUnpausedEvent
	(*DepositForBurn)(nil),                   // 12: circle.cctp.v1.DepositForBurn
	(*MintAndWithdraw)(nil),                  // 13: circle.cctp.v1.MintAndWithdraw
	(*TokenPairLinked)(nil),                  // 14: circle.cctp.v1.TokenPairLinked
	(*TokenPairUnlinked)(nil),                // 15: circle.cctp.v1.TokenPairUnlinked
	(*MessageSent)(nil),                      // 16: circle.cctp.v1.MessageSent
	(*MessageReceived)(nil),                  // 17: circle.cctp.v1.MessageReceived
	(*MaxMessageBodySizeUpdated)(nil),        // 18: circle.cctp.v1.MaxMessageBodySizeUpdated
	(*RemoteTokenMessengerAdded)(nil),        // 19: circle.cctp.v1.RemoteTokenMessengerAdded
	(*RemoteTokenMessengerRemoved)(nil),      // 20: circle.cctp.v1.RemoteTokenMessengerRemoved
	(*SetBurnLimitPerMessage)(nil),           // 21: circle.cctp.v1.SetBurnLimitPerMessage
}
var file_circle_cctp_v1_events_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_circle_cctp_v1_events_proto_init() }
func file_circle_cctp_v1_events_proto_init() {
	if File_circle_cctp_v1_events_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_circle_cctp_v1_events_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AttesterEnabled); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AttesterDisabled); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SignatureThresholdUpdated); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OwnerUpdated); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*OwnershipTransferStarted); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PauserUpdated); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AttesterManagerUpdated); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TokenControllerUpdated); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BurningAndMintingPausedEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BurningAndMintingUnpausedEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SendingAndReceivingPausedEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SendingAndReceivingUnpausedEvent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DepositForBurn); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MintAndWithdraw); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TokenPairLinked); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TokenPairUnlinked); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MessageSent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MessageReceived); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MaxMessageBodySizeUpdated); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoteTokenMessengerAdded); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RemoteTokenMessengerRemoved); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_circle_cctp_v1_events_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SetBurnLimitPerMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_circle_cctp_v1_events_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   22,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_circle_cctp_v1_events_proto_goTypes,
		DependencyIndexes: file_circle_cctp_v1_events_proto_depIdxs,
		MessageInfos:      file_circle_cctp_v1_events_proto_msgTypes,
	}.Build()
	File_circle_cctp_v1_events_proto = out.File
	file_circle_cctp_v1_events_proto_rawDesc = nil
	file_circle_cctp_v1_events_proto_goTypes = nil
	file_circle_cctp_v1_events_proto_depIdxs = nil
}
