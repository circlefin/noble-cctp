// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: circle/cctp/v1/events.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// *
// Emitted when an attester is enabled
// @param attester newly enabled attester
type AttesterEnabled struct {
	Attester string `protobuf:"bytes,1,opt,name=attester,proto3" json:"attester,omitempty"`
}

func (m *AttesterEnabled) Reset()         { *m = AttesterEnabled{} }
func (m *AttesterEnabled) String() string { return proto.CompactTextString(m) }
func (*AttesterEnabled) ProtoMessage()    {}
func (*AttesterEnabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{0}
}
func (m *AttesterEnabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterEnabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterEnabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterEnabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterEnabled.Merge(m, src)
}
func (m *AttesterEnabled) XXX_Size() int {
	return m.Size()
}
func (m *AttesterEnabled) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterEnabled.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterEnabled proto.InternalMessageInfo

func (m *AttesterEnabled) GetAttester() string {
	if m != nil {
		return m.Attester
	}
	return ""
}

// *
// Emitted when an attester is disabled
// @param attester newly disabled attester
type AttesterDisabled struct {
	Attester string `protobuf:"bytes,1,opt,name=attester,proto3" json:"attester,omitempty"`
}

func (m *AttesterDisabled) Reset()         { *m = AttesterDisabled{} }
func (m *AttesterDisabled) String() string { return proto.CompactTextString(m) }
func (*AttesterDisabled) ProtoMessage()    {}
func (*AttesterDisabled) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{1}
}
func (m *AttesterDisabled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterDisabled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterDisabled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterDisabled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterDisabled.Merge(m, src)
}
func (m *AttesterDisabled) XXX_Size() int {
	return m.Size()
}
func (m *AttesterDisabled) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterDisabled.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterDisabled proto.InternalMessageInfo

func (m *AttesterDisabled) GetAttester() string {
	if m != nil {
		return m.Attester
	}
	return ""
}

// *
// Emitted when threshold number of attestations (m in m/n multisig) is updated
// @param old_signature_threshold old signature threshold
// @param new_signature_threshold new signature threshold
type SignatureThresholdUpdated struct {
	OldSignatureThreshold uint64 `protobuf:"varint,1,opt,name=old_signature_threshold,json=oldSignatureThreshold,proto3" json:"old_signature_threshold,omitempty"`
	NewSignatureThreshold uint64 `protobuf:"varint,2,opt,name=new_signature_threshold,json=newSignatureThreshold,proto3" json:"new_signature_threshold,omitempty"`
}

func (m *SignatureThresholdUpdated) Reset()         { *m = SignatureThresholdUpdated{} }
func (m *SignatureThresholdUpdated) String() string { return proto.CompactTextString(m) }
func (*SignatureThresholdUpdated) ProtoMessage()    {}
func (*SignatureThresholdUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{2}
}
func (m *SignatureThresholdUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureThresholdUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureThresholdUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureThresholdUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureThresholdUpdated.Merge(m, src)
}
func (m *SignatureThresholdUpdated) XXX_Size() int {
	return m.Size()
}
func (m *SignatureThresholdUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureThresholdUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureThresholdUpdated proto.InternalMessageInfo

func (m *SignatureThresholdUpdated) GetOldSignatureThreshold() uint64 {
	if m != nil {
		return m.OldSignatureThreshold
	}
	return 0
}

func (m *SignatureThresholdUpdated) GetNewSignatureThreshold() uint64 {
	if m != nil {
		return m.NewSignatureThreshold
	}
	return 0
}

// *
// Emitted when owner address is updated
// @param previous_owner representing the address of the previous owner
// @param new_owner representing the address of the new owner
type OwnerUpdated struct {
	PreviousOwner string `protobuf:"bytes,1,opt,name=previous_owner,json=previousOwner,proto3" json:"previous_owner,omitempty"`
	NewOwner      string `protobuf:"bytes,2,opt,name=new_owner,json=newOwner,proto3" json:"new_owner,omitempty"`
}

func (m *OwnerUpdated) Reset()         { *m = OwnerUpdated{} }
func (m *OwnerUpdated) String() string { return proto.CompactTextString(m) }
func (*OwnerUpdated) ProtoMessage()    {}
func (*OwnerUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{3}
}
func (m *OwnerUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnerUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnerUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnerUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnerUpdated.Merge(m, src)
}
func (m *OwnerUpdated) XXX_Size() int {
	return m.Size()
}
func (m *OwnerUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnerUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_OwnerUpdated proto.InternalMessageInfo

func (m *OwnerUpdated) GetPreviousOwner() string {
	if m != nil {
		return m.PreviousOwner
	}
	return ""
}

func (m *OwnerUpdated) GetNewOwner() string {
	if m != nil {
		return m.NewOwner
	}
	return ""
}

// *
// Emitted when starting the two stage transfer ownership process
// @param previousOwner representing the address of the previous owner
// @param newOwner representing the address of the new owner
type OwnershipTransferStarted struct {
	PreviousOwner string `protobuf:"bytes,1,opt,name=previous_owner,json=previousOwner,proto3" json:"previous_owner,omitempty"`
	NewOwner      string `protobuf:"bytes,2,opt,name=new_owner,json=newOwner,proto3" json:"new_owner,omitempty"`
}

func (m *OwnershipTransferStarted) Reset()         { *m = OwnershipTransferStarted{} }
func (m *OwnershipTransferStarted) String() string { return proto.CompactTextString(m) }
func (*OwnershipTransferStarted) ProtoMessage()    {}
func (*OwnershipTransferStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{4}
}
func (m *OwnershipTransferStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnershipTransferStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnershipTransferStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnershipTransferStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnershipTransferStarted.Merge(m, src)
}
func (m *OwnershipTransferStarted) XXX_Size() int {
	return m.Size()
}
func (m *OwnershipTransferStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnershipTransferStarted.DiscardUnknown(m)
}

var xxx_messageInfo_OwnershipTransferStarted proto.InternalMessageInfo

func (m *OwnershipTransferStarted) GetPreviousOwner() string {
	if m != nil {
		return m.PreviousOwner
	}
	return ""
}

func (m *OwnershipTransferStarted) GetNewOwner() string {
	if m != nil {
		return m.NewOwner
	}
	return ""
}

// *
// Emitted when pauser address is updated
// @param previous_pauser representing the address of the previous pauser
// @param new_pauser representing the address of the new pauser
type PauserUpdated struct {
	PreviousPauser string `protobuf:"bytes,1,opt,name=previous_pauser,json=previousPauser,proto3" json:"previous_pauser,omitempty"`
	NewPauser      string `protobuf:"bytes,2,opt,name=new_pauser,json=newPauser,proto3" json:"new_pauser,omitempty"`
}

func (m *PauserUpdated) Reset()         { *m = PauserUpdated{} }
func (m *PauserUpdated) String() string { return proto.CompactTextString(m) }
func (*PauserUpdated) ProtoMessage()    {}
func (*PauserUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{5}
}
func (m *PauserUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PauserUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PauserUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PauserUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PauserUpdated.Merge(m, src)
}
func (m *PauserUpdated) XXX_Size() int {
	return m.Size()
}
func (m *PauserUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_PauserUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_PauserUpdated proto.InternalMessageInfo

func (m *PauserUpdated) GetPreviousPauser() string {
	if m != nil {
		return m.PreviousPauser
	}
	return ""
}

func (m *PauserUpdated) GetNewPauser() string {
	if m != nil {
		return m.NewPauser
	}
	return ""
}

// *
// Emitted when attester manager address is updated
// @param previous_attester_manager representing the address of the previous
// attester manager
// @param new_attester_manager representing the address of the new attester
// manager
type AttesterManagerUpdated struct {
	PreviousAttesterManager string `protobuf:"bytes,1,opt,name=previous_attester_manager,json=previousAttesterManager,proto3" json:"previous_attester_manager,omitempty"`
	NewAttesterManager      string `protobuf:"bytes,2,opt,name=new_attester_manager,json=newAttesterManager,proto3" json:"new_attester_manager,omitempty"`
}

func (m *AttesterManagerUpdated) Reset()         { *m = AttesterManagerUpdated{} }
func (m *AttesterManagerUpdated) String() string { return proto.CompactTextString(m) }
func (*AttesterManagerUpdated) ProtoMessage()    {}
func (*AttesterManagerUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{6}
}
func (m *AttesterManagerUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterManagerUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterManagerUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterManagerUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterManagerUpdated.Merge(m, src)
}
func (m *AttesterManagerUpdated) XXX_Size() int {
	return m.Size()
}
func (m *AttesterManagerUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterManagerUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterManagerUpdated proto.InternalMessageInfo

func (m *AttesterManagerUpdated) GetPreviousAttesterManager() string {
	if m != nil {
		return m.PreviousAttesterManager
	}
	return ""
}

func (m *AttesterManagerUpdated) GetNewAttesterManager() string {
	if m != nil {
		return m.NewAttesterManager
	}
	return ""
}

// *
// Emitted when token controller address is updated
// @param previous_token_controller representing the address of the previous
// token controller
// @param new_token_controller representing the address of the new token
// controller
type TokenControllerUpdated struct {
	PreviousTokenController string `protobuf:"bytes,1,opt,name=previous_token_controller,json=previousTokenController,proto3" json:"previous_token_controller,omitempty"`
	NewTokenController      string `protobuf:"bytes,2,opt,name=new_token_controller,json=newTokenController,proto3" json:"new_token_controller,omitempty"`
}

func (m *TokenControllerUpdated) Reset()         { *m = TokenControllerUpdated{} }
func (m *TokenControllerUpdated) String() string { return proto.CompactTextString(m) }
func (*TokenControllerUpdated) ProtoMessage()    {}
func (*TokenControllerUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{7}
}
func (m *TokenControllerUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenControllerUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenControllerUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenControllerUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenControllerUpdated.Merge(m, src)
}
func (m *TokenControllerUpdated) XXX_Size() int {
	return m.Size()
}
func (m *TokenControllerUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenControllerUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_TokenControllerUpdated proto.InternalMessageInfo

func (m *TokenControllerUpdated) GetPreviousTokenController() string {
	if m != nil {
		return m.PreviousTokenController
	}
	return ""
}

func (m *TokenControllerUpdated) GetNewTokenController() string {
	if m != nil {
		return m.NewTokenController
	}
	return ""
}

// *
// Emitted when burning and minting tokens is paused
type BurningAndMintingPausedEvent struct {
}

func (m *BurningAndMintingPausedEvent) Reset()         { *m = BurningAndMintingPausedEvent{} }
func (m *BurningAndMintingPausedEvent) String() string { return proto.CompactTextString(m) }
func (*BurningAndMintingPausedEvent) ProtoMessage()    {}
func (*BurningAndMintingPausedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{8}
}
func (m *BurningAndMintingPausedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurningAndMintingPausedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurningAndMintingPausedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurningAndMintingPausedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurningAndMintingPausedEvent.Merge(m, src)
}
func (m *BurningAndMintingPausedEvent) XXX_Size() int {
	return m.Size()
}
func (m *BurningAndMintingPausedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_BurningAndMintingPausedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_BurningAndMintingPausedEvent proto.InternalMessageInfo

// *
// Emitted when burning and minting tokens is unpaused
type BurningAndMintingUnpausedEvent struct {
}

func (m *BurningAndMintingUnpausedEvent) Reset()         { *m = BurningAndMintingUnpausedEvent{} }
func (m *BurningAndMintingUnpausedEvent) String() string { return proto.CompactTextString(m) }
func (*BurningAndMintingUnpausedEvent) ProtoMessage()    {}
func (*BurningAndMintingUnpausedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{9}
}
func (m *BurningAndMintingUnpausedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurningAndMintingUnpausedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurningAndMintingUnpausedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurningAndMintingUnpausedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurningAndMintingUnpausedEvent.Merge(m, src)
}
func (m *BurningAndMintingUnpausedEvent) XXX_Size() int {
	return m.Size()
}
func (m *BurningAndMintingUnpausedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_BurningAndMintingUnpausedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_BurningAndMintingUnpausedEvent proto.InternalMessageInfo

// *
// Emitted when sending and receiving messages is paused
type SendingAndReceivingPausedEvent struct {
}

func (m *SendingAndReceivingPausedEvent) Reset()         { *m = SendingAndReceivingPausedEvent{} }
func (m *SendingAndReceivingPausedEvent) String() string { return proto.CompactTextString(m) }
func (*SendingAndReceivingPausedEvent) ProtoMessage()    {}
func (*SendingAndReceivingPausedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{10}
}
func (m *SendingAndReceivingPausedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendingAndReceivingPausedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendingAndReceivingPausedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendingAndReceivingPausedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendingAndReceivingPausedEvent.Merge(m, src)
}
func (m *SendingAndReceivingPausedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SendingAndReceivingPausedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SendingAndReceivingPausedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SendingAndReceivingPausedEvent proto.InternalMessageInfo

// *
// Emitted when sending and receiving messages is paused
type SendingAndReceivingUnpausedEvent struct {
}

func (m *SendingAndReceivingUnpausedEvent) Reset()         { *m = SendingAndReceivingUnpausedEvent{} }
func (m *SendingAndReceivingUnpausedEvent) String() string { return proto.CompactTextString(m) }
func (*SendingAndReceivingUnpausedEvent) ProtoMessage()    {}
func (*SendingAndReceivingUnpausedEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{11}
}
func (m *SendingAndReceivingUnpausedEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendingAndReceivingUnpausedEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendingAndReceivingUnpausedEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendingAndReceivingUnpausedEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendingAndReceivingUnpausedEvent.Merge(m, src)
}
func (m *SendingAndReceivingUnpausedEvent) XXX_Size() int {
	return m.Size()
}
func (m *SendingAndReceivingUnpausedEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SendingAndReceivingUnpausedEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SendingAndReceivingUnpausedEvent proto.InternalMessageInfo

// *
// Emitted when a DepositForBurn message is sent
// @param nonce unique nonce reserved by message
// @param burn_token address of token burnt on source domain
// @param amount deposit amount
// @param depositor address where deposit is transferred from
// @param mint_recipient address receiving minted tokens on destination domain
// as bytes32
// @param destination_domain destination domain
// @param destination_token_messenger address of TokenMessenger on destination
// domain as bytes32
// @param destination_caller authorized caller as bytes32 of receiveMessage() on
// destination domain, if not equal to bytes32(0). If equal to bytes32(0), any
// address can call receiveMessage().
type DepositForBurn struct {
	Nonce                     uint64                `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	BurnToken                 string                `protobuf:"bytes,2,opt,name=burn_token,json=burnToken,proto3" json:"burn_token,omitempty"`
	Amount                    cosmossdk_io_math.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	Depositor                 string                `protobuf:"bytes,4,opt,name=depositor,proto3" json:"depositor,omitempty"`
	MintRecipient             []byte                `protobuf:"bytes,5,opt,name=mint_recipient,json=mintRecipient,proto3" json:"mint_recipient,omitempty"`
	DestinationDomain         uint32                `protobuf:"varint,6,opt,name=destination_domain,json=destinationDomain,proto3" json:"destination_domain,omitempty"`
	DestinationTokenMessenger []byte                `protobuf:"bytes,7,opt,name=destination_token_messenger,json=destinationTokenMessenger,proto3" json:"destination_token_messenger,omitempty"`
	DestinationCaller         []byte                `protobuf:"bytes,8,opt,name=destination_caller,json=destinationCaller,proto3" json:"destination_caller,omitempty"`
}

func (m *DepositForBurn) Reset()         { *m = DepositForBurn{} }
func (m *DepositForBurn) String() string { return proto.CompactTextString(m) }
func (*DepositForBurn) ProtoMessage()    {}
func (*DepositForBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{12}
}
func (m *DepositForBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositForBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositForBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositForBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositForBurn.Merge(m, src)
}
func (m *DepositForBurn) XXX_Size() int {
	return m.Size()
}
func (m *DepositForBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositForBurn.DiscardUnknown(m)
}

var xxx_messageInfo_DepositForBurn proto.InternalMessageInfo

func (m *DepositForBurn) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *DepositForBurn) GetBurnToken() string {
	if m != nil {
		return m.BurnToken
	}
	return ""
}

func (m *DepositForBurn) GetDepositor() string {
	if m != nil {
		return m.Depositor
	}
	return ""
}

func (m *DepositForBurn) GetMintRecipient() []byte {
	if m != nil {
		return m.MintRecipient
	}
	return nil
}

func (m *DepositForBurn) GetDestinationDomain() uint32 {
	if m != nil {
		return m.DestinationDomain
	}
	return 0
}

func (m *DepositForBurn) GetDestinationTokenMessenger() []byte {
	if m != nil {
		return m.DestinationTokenMessenger
	}
	return nil
}

func (m *DepositForBurn) GetDestinationCaller() []byte {
	if m != nil {
		return m.DestinationCaller
	}
	return nil
}

// *
// Emitted when tokens are minted
// @param mint_recipient recipient address of minted tokens
// @param amount amount of minted tokens
// @param mint_token contract address of minted token
type MintAndWithdraw struct {
	MintRecipient []byte                `protobuf:"bytes,1,opt,name=mint_recipient,json=mintRecipient,proto3" json:"mint_recipient,omitempty"`
	Amount        cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=cosmossdk.io/math.Int" json:"amount"`
	MintToken     string                `protobuf:"bytes,3,opt,name=mint_token,json=mintToken,proto3" json:"mint_token,omitempty"`
}

func (m *MintAndWithdraw) Reset()         { *m = MintAndWithdraw{} }
func (m *MintAndWithdraw) String() string { return proto.CompactTextString(m) }
func (*MintAndWithdraw) ProtoMessage()    {}
func (*MintAndWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{13}
}
func (m *MintAndWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MintAndWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MintAndWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MintAndWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintAndWithdraw.Merge(m, src)
}
func (m *MintAndWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MintAndWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MintAndWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MintAndWithdraw proto.InternalMessageInfo

func (m *MintAndWithdraw) GetMintRecipient() []byte {
	if m != nil {
		return m.MintRecipient
	}
	return nil
}

func (m *MintAndWithdraw) GetMintToken() string {
	if m != nil {
		return m.MintToken
	}
	return ""
}

// *
// Emitted when a token pair is linked
// @param local_token local token to support
// @param remote_domain remote domain
// @param remote_token token on `remoteDomain` corresponding to `localToken`
type TokenPairLinked struct {
	LocalToken   string `protobuf:"bytes,1,opt,name=local_token,json=localToken,proto3" json:"local_token,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remote_domain,json=remoteDomain,proto3" json:"remote_domain,omitempty"`
	RemoteToken  []byte `protobuf:"bytes,3,opt,name=remote_token,json=remoteToken,proto3" json:"remote_token,omitempty"`
}

func (m *TokenPairLinked) Reset()         { *m = TokenPairLinked{} }
func (m *TokenPairLinked) String() string { return proto.CompactTextString(m) }
func (*TokenPairLinked) ProtoMessage()    {}
func (*TokenPairLinked) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{14}
}
func (m *TokenPairLinked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenPairLinked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenPairLinked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenPairLinked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenPairLinked.Merge(m, src)
}
func (m *TokenPairLinked) XXX_Size() int {
	return m.Size()
}
func (m *TokenPairLinked) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenPairLinked.DiscardUnknown(m)
}

var xxx_messageInfo_TokenPairLinked proto.InternalMessageInfo

func (m *TokenPairLinked) GetLocalToken() string {
	if m != nil {
		return m.LocalToken
	}
	return ""
}

func (m *TokenPairLinked) GetRemoteDomain() uint32 {
	if m != nil {
		return m.RemoteDomain
	}
	return 0
}

func (m *TokenPairLinked) GetRemoteToken() []byte {
	if m != nil {
		return m.RemoteToken
	}
	return nil
}

// *
// Emitted when a token pair is unlinked
// @param local_token local token address
// @param remote_domain remote domain
// @param remote_token token on `remoteDomain` unlinked from `localToken`
type TokenPairUnlinked struct {
	LocalToken   string `protobuf:"bytes,1,opt,name=local_token,json=localToken,proto3" json:"local_token,omitempty"`
	RemoteDomain uint32 `protobuf:"varint,2,opt,name=remote_domain,json=remoteDomain,proto3" json:"remote_domain,omitempty"`
	RemoteToken  []byte `protobuf:"bytes,3,opt,name=remote_token,json=remoteToken,proto3" json:"remote_token,omitempty"`
}

func (m *TokenPairUnlinked) Reset()         { *m = TokenPairUnlinked{} }
func (m *TokenPairUnlinked) String() string { return proto.CompactTextString(m) }
func (*TokenPairUnlinked) ProtoMessage()    {}
func (*TokenPairUnlinked) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{15}
}
func (m *TokenPairUnlinked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenPairUnlinked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenPairUnlinked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenPairUnlinked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenPairUnlinked.Merge(m, src)
}
func (m *TokenPairUnlinked) XXX_Size() int {
	return m.Size()
}
func (m *TokenPairUnlinked) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenPairUnlinked.DiscardUnknown(m)
}

var xxx_messageInfo_TokenPairUnlinked proto.InternalMessageInfo

func (m *TokenPairUnlinked) GetLocalToken() string {
	if m != nil {
		return m.LocalToken
	}
	return ""
}

func (m *TokenPairUnlinked) GetRemoteDomain() uint32 {
	if m != nil {
		return m.RemoteDomain
	}
	return 0
}

func (m *TokenPairUnlinked) GetRemoteToken() []byte {
	if m != nil {
		return m.RemoteToken
	}
	return nil
}

// *
// Emitted when a new message is dispatched
// @param message Raw bytes of message
type MessageSent struct {
	Message []byte `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *MessageSent) Reset()         { *m = MessageSent{} }
func (m *MessageSent) String() string { return proto.CompactTextString(m) }
func (*MessageSent) ProtoMessage()    {}
func (*MessageSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{16}
}
func (m *MessageSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageSent.Merge(m, src)
}
func (m *MessageSent) XXX_Size() int {
	return m.Size()
}
func (m *MessageSent) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageSent.DiscardUnknown(m)
}

var xxx_messageInfo_MessageSent proto.InternalMessageInfo

func (m *MessageSent) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

// *
// Emitted when a new message is received
// @param caller caller (msg.sender) on destination domain
// @param source_domain the source domain this message originated from
// @param nonce the nonce unique to this message
// @param sender the sender of this message
// @param message_body message body bytes
type MessageReceived struct {
	Caller       string `protobuf:"bytes,1,opt,name=caller,proto3" json:"caller,omitempty"`
	SourceDomain uint32 `protobuf:"varint,2,opt,name=source_domain,json=sourceDomain,proto3" json:"source_domain,omitempty"`
	Nonce        uint64 `protobuf:"varint,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Sender       []byte `protobuf:"bytes,4,opt,name=sender,proto3" json:"sender,omitempty"`
	MessageBody  []byte `protobuf:"bytes,5,opt,name=message_body,json=messageBody,proto3" json:"message_body,omitempty"`
}

func (m *MessageReceived) Reset()         { *m = MessageReceived{} }
func (m *MessageReceived) String() string { return proto.CompactTextString(m) }
func (*MessageReceived) ProtoMessage()    {}
func (*MessageReceived) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{17}
}
func (m *MessageReceived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageReceived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageReceived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageReceived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageReceived.Merge(m, src)
}
func (m *MessageReceived) XXX_Size() int {
	return m.Size()
}
func (m *MessageReceived) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageReceived.DiscardUnknown(m)
}

var xxx_messageInfo_MessageReceived proto.InternalMessageInfo

func (m *MessageReceived) GetCaller() string {
	if m != nil {
		return m.Caller
	}
	return ""
}

func (m *MessageReceived) GetSourceDomain() uint32 {
	if m != nil {
		return m.SourceDomain
	}
	return 0
}

func (m *MessageReceived) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *MessageReceived) GetSender() []byte {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MessageReceived) GetMessageBody() []byte {
	if m != nil {
		return m.MessageBody
	}
	return nil
}

// *
// Emitted when max message body size is updated
// @param new_max_message_body_size new maximum message body size, in bytes
type MaxMessageBodySizeUpdated struct {
	NewMaxMessageBodySize uint64 `protobuf:"varint,1,opt,name=new_max_message_body_size,json=newMaxMessageBodySize,proto3" json:"new_max_message_body_size,omitempty"`
}

func (m *MaxMessageBodySizeUpdated) Reset()         { *m = MaxMessageBodySizeUpdated{} }
func (m *MaxMessageBodySizeUpdated) String() string { return proto.CompactTextString(m) }
func (*MaxMessageBodySizeUpdated) ProtoMessage()    {}
func (*MaxMessageBodySizeUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{18}
}
func (m *MaxMessageBodySizeUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxMessageBodySizeUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxMessageBodySizeUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxMessageBodySizeUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxMessageBodySizeUpdated.Merge(m, src)
}
func (m *MaxMessageBodySizeUpdated) XXX_Size() int {
	return m.Size()
}
func (m *MaxMessageBodySizeUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxMessageBodySizeUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_MaxMessageBodySizeUpdated proto.InternalMessageInfo

func (m *MaxMessageBodySizeUpdated) GetNewMaxMessageBodySize() uint64 {
	if m != nil {
		return m.NewMaxMessageBodySize
	}
	return 0
}

// *
// Emitted when a RemoteTokenMessenger is added
// @param domain remote domain
// @param remote_token_messenger RemoteTokenMessenger on domain
type RemoteTokenMessengerAdded struct {
	Domain               uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	RemoteTokenMessenger []byte `protobuf:"bytes,2,opt,name=remote_token_messenger,json=remoteTokenMessenger,proto3" json:"remote_token_messenger,omitempty"`
}

func (m *RemoteTokenMessengerAdded) Reset()         { *m = RemoteTokenMessengerAdded{} }
func (m *RemoteTokenMessengerAdded) String() string { return proto.CompactTextString(m) }
func (*RemoteTokenMessengerAdded) ProtoMessage()    {}
func (*RemoteTokenMessengerAdded) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{19}
}
func (m *RemoteTokenMessengerAdded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteTokenMessengerAdded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteTokenMessengerAdded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteTokenMessengerAdded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteTokenMessengerAdded.Merge(m, src)
}
func (m *RemoteTokenMessengerAdded) XXX_Size() int {
	return m.Size()
}
func (m *RemoteTokenMessengerAdded) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteTokenMessengerAdded.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteTokenMessengerAdded proto.InternalMessageInfo

func (m *RemoteTokenMessengerAdded) GetDomain() uint32 {
	if m != nil {
		return m.Domain
	}
	return 0
}

func (m *RemoteTokenMessengerAdded) GetRemoteTokenMessenger() []byte {
	if m != nil {
		return m.RemoteTokenMessenger
	}
	return nil
}

// *
// Emitted when a RemoteTokenMessenger is removed
// @param domain remote domain
// @param remote_token_messenger RemoteTokenMessenger on domain
type RemoteTokenMessengerRemoved struct {
	Domain               uint32 `protobuf:"varint,1,opt,name=domain,proto3" json:"domain,omitempty"`
	RemoteTokenMessenger []byte `protobuf:"bytes,2,opt,name=remote_token_messenger,json=remoteTokenMessenger,proto3" json:"remote_token_messenger,omitempty"`
}

func (m *RemoteTokenMessengerRemoved) Reset()         { *m = RemoteTokenMessengerRemoved{} }
func (m *RemoteTokenMessengerRemoved) String() string { return proto.CompactTextString(m) }
func (*RemoteTokenMessengerRemoved) ProtoMessage()    {}
func (*RemoteTokenMessengerRemoved) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{20}
}
func (m *RemoteTokenMessengerRemoved) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteTokenMessengerRemoved) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteTokenMessengerRemoved.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteTokenMessengerRemoved) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteTokenMessengerRemoved.Merge(m, src)
}
func (m *RemoteTokenMessengerRemoved) XXX_Size() int {
	return m.Size()
}
func (m *RemoteTokenMessengerRemoved) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteTokenMessengerRemoved.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteTokenMessengerRemoved proto.InternalMessageInfo

func (m *RemoteTokenMessengerRemoved) GetDomain() uint32 {
	if m != nil {
		return m.Domain
	}
	return 0
}

func (m *RemoteTokenMessengerRemoved) GetRemoteTokenMessenger() []byte {
	if m != nil {
		return m.RemoteTokenMessenger
	}
	return nil
}

// *
// Emitted when max burn amount per message is updated
// @param local_token
// @param old_amount old max burn amount
// @param new_amount new max burn amount
type SetBurnLimitPerMessage struct {
	Token               string                `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	BurnLimitPerMessage cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=burn_limit_per_message,json=burnLimitPerMessage,proto3,customtype=cosmossdk.io/math.Int" json:"burn_limit_per_message"`
}

func (m *SetBurnLimitPerMessage) Reset()         { *m = SetBurnLimitPerMessage{} }
func (m *SetBurnLimitPerMessage) String() string { return proto.CompactTextString(m) }
func (*SetBurnLimitPerMessage) ProtoMessage()    {}
func (*SetBurnLimitPerMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_e7ce5881ab629356, []int{21}
}
func (m *SetBurnLimitPerMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetBurnLimitPerMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetBurnLimitPerMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetBurnLimitPerMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetBurnLimitPerMessage.Merge(m, src)
}
func (m *SetBurnLimitPerMessage) XXX_Size() int {
	return m.Size()
}
func (m *SetBurnLimitPerMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SetBurnLimitPerMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SetBurnLimitPerMessage proto.InternalMessageInfo

func (m *SetBurnLimitPerMessage) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func init() {
	proto.RegisterType((*AttesterEnabled)(nil), "circle.cctp.v1.AttesterEnabled")
	proto.RegisterType((*AttesterDisabled)(nil), "circle.cctp.v1.AttesterDisabled")
	proto.RegisterType((*SignatureThresholdUpdated)(nil), "circle.cctp.v1.SignatureThresholdUpdated")
	proto.RegisterType((*OwnerUpdated)(nil), "circle.cctp.v1.OwnerUpdated")
	proto.RegisterType((*OwnershipTransferStarted)(nil), "circle.cctp.v1.OwnershipTransferStarted")
	proto.RegisterType((*PauserUpdated)(nil), "circle.cctp.v1.PauserUpdated")
	proto.RegisterType((*AttesterManagerUpdated)(nil), "circle.cctp.v1.AttesterManagerUpdated")
	proto.RegisterType((*TokenControllerUpdated)(nil), "circle.cctp.v1.TokenControllerUpdated")
	proto.RegisterType((*BurningAndMintingPausedEvent)(nil), "circle.cctp.v1.BurningAndMintingPausedEvent")
	proto.RegisterType((*BurningAndMintingUnpausedEvent)(nil), "circle.cctp.v1.BurningAndMintingUnpausedEvent")
	proto.RegisterType((*SendingAndReceivingPausedEvent)(nil), "circle.cctp.v1.SendingAndReceivingPausedEvent")
	proto.RegisterType((*SendingAndReceivingUnpausedEvent)(nil), "circle.cctp.v1.SendingAndReceivingUnpausedEvent")
	proto.RegisterType((*DepositForBurn)(nil), "circle.cctp.v1.DepositForBurn")
	proto.RegisterType((*MintAndWithdraw)(nil), "circle.cctp.v1.MintAndWithdraw")
	proto.RegisterType((*TokenPairLinked)(nil), "circle.cctp.v1.TokenPairLinked")
	proto.RegisterType((*TokenPairUnlinked)(nil), "circle.cctp.v1.TokenPairUnlinked")
	proto.RegisterType((*MessageSent)(nil), "circle.cctp.v1.MessageSent")
	proto.RegisterType((*MessageReceived)(nil), "circle.cctp.v1.MessageReceived")
	proto.RegisterType((*MaxMessageBodySizeUpdated)(nil), "circle.cctp.v1.MaxMessageBodySizeUpdated")
	proto.RegisterType((*RemoteTokenMessengerAdded)(nil), "circle.cctp.v1.RemoteTokenMessengerAdded")
	proto.RegisterType((*RemoteTokenMessengerRemoved)(nil), "circle.cctp.v1.RemoteTokenMessengerRemoved")
	proto.RegisterType((*SetBurnLimitPerMessage)(nil), "circle.cctp.v1.SetBurnLimitPerMessage")
}

func init() { proto.RegisterFile("circle/cctp/v1/events.proto", fileDescriptor_e7ce5881ab629356) }

var fileDescriptor_e7ce5881ab629356 = []byte{
	// 986 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x3a, 0xad, 0xdb, 0xbc, 0xd8, 0x09, 0x5d, 0x52, 0xd7, 0x6e, 0x1a, 0xc7, 0x2c, 0x42,
	0xcd, 0x81, 0xd8, 0x54, 0xfc, 0x11, 0xe2, 0x80, 0x94, 0x34, 0xad, 0x84, 0x54, 0x8b, 0x68, 0x9d,
	0xa8, 0x12, 0x07, 0x56, 0xe3, 0x9d, 0xa9, 0x3d, 0xca, 0xee, 0xcc, 0x6a, 0x66, 0x6c, 0x27, 0x11,
	0x27, 0x0e, 0x5c, 0x90, 0x10, 0xdf, 0x80, 0xaf, 0xd3, 0x63, 0x8f, 0x88, 0x43, 0x41, 0xc9, 0x17,
	0x41, 0xf3, 0x67, 0xed, 0xad, 0x6d, 0x09, 0x90, 0x22, 0x6e, 0xfb, 0xde, 0xfb, 0xbd, 0xf7, 0x7b,
	0x7f, 0x77, 0x17, 0xb6, 0x63, 0x2a, 0xe2, 0x84, 0x74, 0xe2, 0x58, 0x65, 0x9d, 0xf1, 0x93, 0x0e,
	0x19, 0x13, 0xa6, 0x64, 0x3b, 0x13, 0x5c, 0x71, 0x7f, 0xc3, 0x1a, 0xdb, 0xda, 0xd8, 0x1e, 0x3f,
	0x79, 0xb8, 0x35, 0xe0, 0x03, 0x6e, 0x4c, 0x1d, 0xfd, 0x64, 0x51, 0xc1, 0x3e, 0x6c, 0x1e, 0x28,
	0x45, 0xa4, 0x22, 0xe2, 0x19, 0x43, 0xfd, 0x84, 0x60, 0xff, 0x21, 0xdc, 0x45, 0x4e, 0x55, 0xf7,
	0x5a, 0xde, 0xde, 0x5a, 0x38, 0x95, 0x83, 0x36, 0xbc, 0x97, 0xc3, 0x8f, 0xa8, 0xfc, 0x67, 0xfc,
	0xcf, 0x1e, 0x34, 0x7a, 0x74, 0xc0, 0x90, 0x1a, 0x09, 0x72, 0x32, 0x14, 0x44, 0x0e, 0x79, 0x82,
	0x4f, 0x33, 0x8c, 0x14, 0xc1, 0xfe, 0x17, 0xf0, 0x80, 0x27, 0x38, 0x92, 0x39, 0x20, 0x52, 0x39,
	0xc2, 0x04, 0xba, 0x15, 0xde, 0xe7, 0x09, 0x5e, 0x74, 0xd7, 0x7e, 0x8c, 0x4c, 0x96, 0xfa, 0x95,
	0xac, 0x1f, 0x23, 0x93, 0x45, 0xbf, 0x20, 0x84, 0xca, 0xb7, 0x13, 0x46, 0x44, 0xce, 0xff, 0x11,
	0x6c, 0x64, 0x82, 0x8c, 0x29, 0x1f, 0xc9, 0x88, 0x6b, 0x83, 0xcb, 0xbf, 0x9a, 0x6b, 0x0d, 0xda,
	0xdf, 0x86, 0x35, 0x4d, 0x67, 0x11, 0x25, 0x5b, 0x21, 0x23, 0x13, 0x63, 0x0c, 0xbe, 0x87, 0xba,
	0x79, 0x90, 0x43, 0x9a, 0x9d, 0x08, 0xc4, 0xe4, 0x2b, 0x22, 0x7a, 0x0a, 0x89, 0x9b, 0x8a, 0xff,
	0x12, 0xaa, 0xc7, 0x68, 0x24, 0x67, 0x49, 0x3f, 0x86, 0xcd, 0x69, 0xd0, 0xcc, 0x58, 0x5c, 0xd4,
	0x29, 0x97, 0xc5, 0xfb, 0x3b, 0x00, 0x3a, 0xac, 0xc3, 0xd8, 0xb8, 0x9a, 0xc8, 0x9a, 0x83, 0x9f,
	0x3c, 0xa8, 0xe5, 0xb3, 0xec, 0x22, 0x86, 0x06, 0x33, 0x8a, 0xaf, 0xa0, 0x31, 0xa5, 0xc8, 0x47,
	0x19, 0xa5, 0x16, 0xe3, 0xc8, 0x1e, 0xe4, 0x80, 0xb9, 0x10, 0xfe, 0x27, 0xb0, 0xa5, 0x59, 0x17,
	0xdc, 0x2c, 0xbf, 0xcf, 0xc8, 0x64, 0xce, 0xc3, 0x24, 0x72, 0xc2, 0xcf, 0x08, 0x7b, 0xca, 0x99,
	0x12, 0x3c, 0x49, 0x96, 0x27, 0xa2, 0x34, 0x24, 0x8a, 0xa7, 0x98, 0xf9, 0x44, 0xe6, 0x42, 0xe4,
	0x89, 0x2c, 0xb8, 0xcd, 0x12, 0x99, 0xf3, 0x08, 0x9a, 0xf0, 0xe8, 0x70, 0x24, 0x18, 0x65, 0x83,
	0x03, 0x86, 0xbb, 0x94, 0x29, 0xca, 0x06, 0xa6, 0x59, 0xf8, 0x99, 0x3e, 0xac, 0xa0, 0x05, 0xcd,
	0x05, 0xfb, 0x29, 0xcb, 0xde, 0x45, 0xf4, 0x08, 0xc3, 0x16, 0x11, 0x92, 0x98, 0xd0, 0xf1, 0x5c,
	0x8c, 0x00, 0x5a, 0x4b, 0x10, 0xef, 0x46, 0xf9, 0xb3, 0x04, 0x1b, 0x47, 0x24, 0xe3, 0x92, 0xaa,
	0xe7, 0x5c, 0x68, 0x4a, 0x7f, 0x0b, 0x6e, 0x33, 0xce, 0x62, 0xe2, 0xee, 0xc2, 0x0a, 0x7a, 0xc2,
	0xfd, 0x91, 0x60, 0xb6, 0xc6, 0x7c, 0xc2, 0x5a, 0x63, 0x2a, 0xf3, 0x3f, 0x87, 0x32, 0x4a, 0xf9,
	0x88, 0xa9, 0xfa, 0xaa, 0x36, 0x1d, 0xee, 0xbc, 0x7e, 0xbb, 0xbb, 0xf2, 0xc7, 0xdb, 0xdd, 0xfb,
	0x31, 0x97, 0x29, 0x97, 0x12, 0x9f, 0xb5, 0x29, 0xef, 0xa4, 0x48, 0x0d, 0xdb, 0xdf, 0x30, 0x15,
	0x3a, 0xb0, 0xff, 0x08, 0xd6, 0xb0, 0x65, 0xe7, 0xa2, 0x7e, 0xcb, 0x06, 0x9d, 0x2a, 0xf4, 0x4e,
	0xa7, 0x94, 0xa9, 0x48, 0x90, 0x98, 0x66, 0x94, 0x30, 0x55, 0xbf, 0xdd, 0xf2, 0xf6, 0x2a, 0x61,
	0x55, 0x6b, 0xc3, 0x5c, 0xe9, 0xef, 0x83, 0x8f, 0x89, 0x54, 0x94, 0x21, 0x45, 0x39, 0x8b, 0x30,
	0x4f, 0x11, 0x65, 0xf5, 0x72, 0xcb, 0xdb, 0xab, 0x86, 0xf7, 0x0a, 0x96, 0x23, 0x63, 0xf0, 0xbf,
	0x86, 0xed, 0x22, 0xdc, 0x0e, 0x2d, 0x25, 0x52, 0x12, 0xa6, 0x97, 0xe7, 0x8e, 0xa1, 0x68, 0x14,
	0x20, 0xa6, 0xc2, 0x6e, 0x0e, 0x98, 0xa7, 0x8b, 0x91, 0x19, 0xf5, 0x5d, 0xe3, 0x56, 0xa4, 0x7b,
	0x6a, 0x0c, 0xc1, 0x2f, 0x1e, 0x6c, 0xea, 0x01, 0x1e, 0x30, 0xfc, 0x92, 0xaa, 0x21, 0x16, 0x68,
	0xb2, 0xa4, 0x30, 0x6f, 0x59, 0x61, 0xb3, 0xa6, 0x96, 0xfe, 0x4b, 0x53, 0x77, 0x00, 0x4c, 0x74,
	0x3b, 0xaa, 0x55, 0xdb, 0x55, 0xad, 0x31, 0x85, 0x04, 0x97, 0xb0, 0x69, 0x1e, 0x8e, 0x11, 0x15,
	0x2f, 0x28, 0x3b, 0x23, 0xd8, 0xdf, 0x85, 0xf5, 0x84, 0xc7, 0x28, 0x71, 0x2e, 0x76, 0xdb, 0xc1,
	0xa8, 0xec, 0x78, 0x3f, 0x84, 0xaa, 0x20, 0x29, 0x57, 0x24, 0xef, 0x6e, 0xc9, 0x74, 0xb7, 0x62,
	0x95, 0xae, 0xb1, 0x1f, 0x80, 0x93, 0x0b, 0xcc, 0x95, 0x70, 0xdd, 0xea, 0x2c, 0xf7, 0x0f, 0x70,
	0x6f, 0xca, 0x7d, 0xca, 0x92, 0xff, 0x99, 0xfd, 0x31, 0xac, 0xeb, 0x31, 0xa2, 0x01, 0xe9, 0xe9,
	0xf6, 0xd6, 0xe1, 0x4e, 0x6a, 0x45, 0xd7, 0xfe, 0x5c, 0x0c, 0x7e, 0xd3, 0x33, 0xb3, 0xcf, 0xf6,
	0x6e, 0x08, 0xf6, 0x6b, 0x50, 0x76, 0xa3, 0xb6, 0x09, 0x3a, 0x49, 0x27, 0x27, 0xf9, 0x48, 0xc4,
	0xf3, 0xc9, 0x59, 0xa5, 0x4b, 0x6e, 0x7a, 0x53, 0xab, 0xc5, 0x9b, 0xaa, 0x41, 0x59, 0x12, 0x86,
	0x89, 0x5d, 0xfd, 0x4a, 0xe8, 0x24, 0x5d, 0x8a, 0xcb, 0x24, 0xea, 0x73, 0x7c, 0xe1, 0xb6, 0x7e,
	0xdd, 0xe9, 0x0e, 0x39, 0xbe, 0x08, 0x4e, 0xa1, 0xd1, 0x45, 0xe7, 0xdd, 0x99, 0xa6, 0x47, 0x2f,
	0x49, 0xfe, 0x2a, 0xfb, 0x12, 0x1a, 0xfa, 0x75, 0x94, 0xa2, 0xf3, 0xa8, 0x18, 0x27, 0x92, 0xf4,
	0x32, 0xbf, 0x6a, 0xfd, 0xd5, 0x5a, 0x0c, 0x10, 0x50, 0x68, 0x84, 0xb3, 0x86, 0x4d, 0x77, 0xfe,
	0x00, 0x63, 0xdb, 0x01, 0x57, 0xa2, 0x67, 0x4a, 0x74, 0x92, 0xff, 0x19, 0xd4, 0x8a, 0x9d, 0x2f,
	0xdc, 0x52, 0xc9, 0x24, 0xbe, 0x25, 0x96, 0x84, 0x0c, 0xce, 0x60, 0x7b, 0x19, 0x95, 0xd6, 0x8d,
	0x6f, 0x9c, 0xec, 0x47, 0x0f, 0x6a, 0x3d, 0xa2, 0xf4, 0xfb, 0xed, 0x05, 0x4d, 0xa9, 0x3a, 0x26,
	0xc2, 0x95, 0xae, 0x47, 0x53, 0xdc, 0x3b, 0x2b, 0xf8, 0x21, 0xd4, 0xcc, 0xeb, 0x2e, 0xd1, 0xe8,
	0x28, 0xd3, 0x1f, 0x17, 0xb7, 0x2a, 0xff, 0xea, 0x14, 0xdf, 0xef, 0x2f, 0x32, 0x1d, 0x3e, 0x7f,
	0x7d, 0xd5, 0xf4, 0xde, 0x5c, 0x35, 0xbd, 0xbf, 0xae, 0x9a, 0xde, 0xaf, 0xd7, 0xcd, 0x95, 0x37,
	0xd7, 0xcd, 0x95, 0xdf, 0xaf, 0x9b, 0x2b, 0xdf, 0x7d, 0x3c, 0xa0, 0x6a, 0x38, 0xea, 0xb7, 0x63,
	0x9e, 0x76, 0xec, 0xaf, 0xd4, 0x2b, 0xca, 0x3a, 0x8c, 0xf7, 0x13, 0xb2, 0x6f, 0x7e, 0xb8, 0xce,
	0xed, 0x7f, 0x97, 0xba, 0xc8, 0x88, 0xec, 0x97, 0xcd, 0xef, 0xd4, 0xa7, 0x7f, 0x07, 0x00, 0x00,
	0xff, 0xff, 0x27, 0x38, 0xf8, 0xe9, 0x93, 0x09, 0x00, 0x00,
}

func (m *AttesterEnabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterEnabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterEnabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attester) > 0 {
		i -= len(m.Attester)
		copy(dAtA[i:], m.Attester)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Attester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttesterDisabled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterDisabled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterDisabled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attester) > 0 {
		i -= len(m.Attester)
		copy(dAtA[i:], m.Attester)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Attester)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignatureThresholdUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureThresholdUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureThresholdUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewSignatureThreshold != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.NewSignatureThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.OldSignatureThreshold != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OldSignatureThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OwnerUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnerUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwnerUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewOwner) > 0 {
		i -= len(m.NewOwner)
		copy(dAtA[i:], m.NewOwner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewOwner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousOwner) > 0 {
		i -= len(m.PreviousOwner)
		copy(dAtA[i:], m.PreviousOwner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousOwner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OwnershipTransferStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnershipTransferStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwnershipTransferStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewOwner) > 0 {
		i -= len(m.NewOwner)
		copy(dAtA[i:], m.NewOwner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewOwner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousOwner) > 0 {
		i -= len(m.PreviousOwner)
		copy(dAtA[i:], m.PreviousOwner)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousOwner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PauserUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PauserUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PauserUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewPauser) > 0 {
		i -= len(m.NewPauser)
		copy(dAtA[i:], m.NewPauser)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewPauser)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousPauser) > 0 {
		i -= len(m.PreviousPauser)
		copy(dAtA[i:], m.PreviousPauser)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousPauser)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttesterManagerUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterManagerUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterManagerUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewAttesterManager) > 0 {
		i -= len(m.NewAttesterManager)
		copy(dAtA[i:], m.NewAttesterManager)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewAttesterManager)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousAttesterManager) > 0 {
		i -= len(m.PreviousAttesterManager)
		copy(dAtA[i:], m.PreviousAttesterManager)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousAttesterManager)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenControllerUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenControllerUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenControllerUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewTokenController) > 0 {
		i -= len(m.NewTokenController)
		copy(dAtA[i:], m.NewTokenController)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewTokenController)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviousTokenController) > 0 {
		i -= len(m.PreviousTokenController)
		copy(dAtA[i:], m.PreviousTokenController)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.PreviousTokenController)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BurningAndMintingPausedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurningAndMintingPausedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurningAndMintingPausedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BurningAndMintingUnpausedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurningAndMintingUnpausedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurningAndMintingUnpausedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SendingAndReceivingPausedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendingAndReceivingPausedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendingAndReceivingPausedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SendingAndReceivingUnpausedEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendingAndReceivingUnpausedEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendingAndReceivingUnpausedEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DepositForBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositForBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositForBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DestinationCaller) > 0 {
		i -= len(m.DestinationCaller)
		copy(dAtA[i:], m.DestinationCaller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DestinationCaller)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DestinationTokenMessenger) > 0 {
		i -= len(m.DestinationTokenMessenger)
		copy(dAtA[i:], m.DestinationTokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.DestinationTokenMessenger)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DestinationDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.DestinationDomain))
		i--
		dAtA[i] = 0x30
	}
	if len(m.MintRecipient) > 0 {
		i -= len(m.MintRecipient)
		copy(dAtA[i:], m.MintRecipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintRecipient)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.BurnToken) > 0 {
		i -= len(m.BurnToken)
		copy(dAtA[i:], m.BurnToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.BurnToken)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MintAndWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MintAndWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MintAndWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MintToken) > 0 {
		i -= len(m.MintToken)
		copy(dAtA[i:], m.MintToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintToken)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MintRecipient) > 0 {
		i -= len(m.MintRecipient)
		copy(dAtA[i:], m.MintRecipient)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MintRecipient)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenPairLinked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenPairLinked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenPairLinked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteToken) > 0 {
		i -= len(m.RemoteToken)
		copy(dAtA[i:], m.RemoteToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RemoteToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RemoteDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RemoteDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalToken) > 0 {
		i -= len(m.LocalToken)
		copy(dAtA[i:], m.LocalToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.LocalToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenPairUnlinked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenPairUnlinked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenPairUnlinked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteToken) > 0 {
		i -= len(m.RemoteToken)
		copy(dAtA[i:], m.RemoteToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RemoteToken)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RemoteDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.RemoteDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LocalToken) > 0 {
		i -= len(m.LocalToken)
		copy(dAtA[i:], m.LocalToken)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.LocalToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageReceived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MessageBody) > 0 {
		i -= len(m.MessageBody)
		copy(dAtA[i:], m.MessageBody)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MessageBody)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nonce != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceDomain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.SourceDomain))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Caller) > 0 {
		i -= len(m.Caller)
		copy(dAtA[i:], m.Caller)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Caller)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MaxMessageBodySizeUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxMessageBodySizeUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxMessageBodySizeUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewMaxMessageBodySize != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.NewMaxMessageBodySize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteTokenMessengerAdded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteTokenMessengerAdded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteTokenMessengerAdded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteTokenMessenger) > 0 {
		i -= len(m.RemoteTokenMessenger)
		copy(dAtA[i:], m.RemoteTokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RemoteTokenMessenger)))
		i--
		dAtA[i] = 0x12
	}
	if m.Domain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteTokenMessengerRemoved) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteTokenMessengerRemoved) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteTokenMessengerRemoved) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RemoteTokenMessenger) > 0 {
		i -= len(m.RemoteTokenMessenger)
		copy(dAtA[i:], m.RemoteTokenMessenger)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.RemoteTokenMessenger)))
		i--
		dAtA[i] = 0x12
	}
	if m.Domain != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetBurnLimitPerMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBurnLimitPerMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetBurnLimitPerMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.BurnLimitPerMessage.Size()
		i -= size
		if _, err := m.BurnLimitPerMessage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttesterEnabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attester)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *AttesterDisabled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Attester)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *SignatureThresholdUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OldSignatureThreshold != 0 {
		n += 1 + sovEvents(uint64(m.OldSignatureThreshold))
	}
	if m.NewSignatureThreshold != 0 {
		n += 1 + sovEvents(uint64(m.NewSignatureThreshold))
	}
	return n
}

func (m *OwnerUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousOwner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewOwner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *OwnershipTransferStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousOwner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewOwner)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *PauserUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousPauser)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewPauser)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *AttesterManagerUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousAttesterManager)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewAttesterManager)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TokenControllerUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviousTokenController)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewTokenController)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *BurningAndMintingPausedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BurningAndMintingUnpausedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SendingAndReceivingPausedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SendingAndReceivingUnpausedEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DepositForBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	l = len(m.BurnToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MintRecipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.DestinationDomain != 0 {
		n += 1 + sovEvents(uint64(m.DestinationDomain))
	}
	l = len(m.DestinationTokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.DestinationCaller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MintAndWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MintRecipient)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = len(m.MintToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TokenPairLinked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RemoteDomain != 0 {
		n += 1 + sovEvents(uint64(m.RemoteDomain))
	}
	l = len(m.RemoteToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TokenPairUnlinked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LocalToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.RemoteDomain != 0 {
		n += 1 + sovEvents(uint64(m.RemoteDomain))
	}
	l = len(m.RemoteToken)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MessageSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MessageReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Caller)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.SourceDomain != 0 {
		n += 1 + sovEvents(uint64(m.SourceDomain))
	}
	if m.Nonce != 0 {
		n += 1 + sovEvents(uint64(m.Nonce))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MessageBody)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *MaxMessageBodySizeUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewMaxMessageBodySize != 0 {
		n += 1 + sovEvents(uint64(m.NewMaxMessageBodySize))
	}
	return n
}

func (m *RemoteTokenMessengerAdded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovEvents(uint64(m.Domain))
	}
	l = len(m.RemoteTokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *RemoteTokenMessengerRemoved) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovEvents(uint64(m.Domain))
	}
	l = len(m.RemoteTokenMessenger)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *SetBurnLimitPerMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = m.BurnLimitPerMessage.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AttesterEnabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterEnabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterEnabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttesterDisabled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterDisabled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterDisabled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureThresholdUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureThresholdUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureThresholdUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldSignatureThreshold", wireType)
			}
			m.OldSignatureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldSignatureThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSignatureThreshold", wireType)
			}
			m.NewSignatureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewSignatureThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnershipTransferStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnershipTransferStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnershipTransferStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PauserUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PauserUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PauserUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousPauser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousPauser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPauser", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPauser = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttesterManagerUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterManagerUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterManagerUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousAttesterManager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousAttesterManager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAttesterManager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAttesterManager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenControllerUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenControllerUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenControllerUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousTokenController", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousTokenController = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTokenController", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTokenController = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurningAndMintingPausedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurningAndMintingPausedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurningAndMintingPausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurningAndMintingUnpausedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurningAndMintingUnpausedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurningAndMintingUnpausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendingAndReceivingPausedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendingAndReceivingPausedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendingAndReceivingPausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendingAndReceivingUnpausedEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendingAndReceivingUnpausedEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendingAndReceivingUnpausedEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositForBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositForBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositForBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRecipient = append(m.MintRecipient[:0], dAtA[iNdEx:postIndex]...)
			if m.MintRecipient == nil {
				m.MintRecipient = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDomain", wireType)
			}
			m.DestinationDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestinationDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationTokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationTokenMessenger = append(m.DestinationTokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.DestinationTokenMessenger == nil {
				m.DestinationTokenMessenger = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationCaller", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationCaller = append(m.DestinationCaller[:0], dAtA[iNdEx:postIndex]...)
			if m.DestinationCaller == nil {
				m.DestinationCaller = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MintAndWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MintAndWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MintAndWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintRecipient", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintRecipient = append(m.MintRecipient[:0], dAtA[iNdEx:postIndex]...)
			if m.MintRecipient == nil {
				m.MintRecipient = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenPairLinked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenPairLinked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenPairLinked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
			}
			m.RemoteDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteToken = append(m.RemoteToken[:0], dAtA[iNdEx:postIndex]...)
			if m.RemoteToken == nil {
				m.RemoteToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenPairUnlinked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenPairUnlinked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenPairUnlinked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteDomain", wireType)
			}
			m.RemoteDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemoteDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteToken", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteToken = append(m.RemoteToken[:0], dAtA[iNdEx:postIndex]...)
			if m.RemoteToken == nil {
				m.RemoteToken = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message[:0], dAtA[iNdEx:postIndex]...)
			if m.Message == nil {
				m.Message = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageReceived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageReceived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageReceived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceDomain", wireType)
			}
			m.SourceDomain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceDomain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageBody = append(m.MessageBody[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageBody == nil {
				m.MessageBody = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaxMessageBodySizeUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxMessageBodySizeUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxMessageBodySizeUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMaxMessageBodySize", wireType)
			}
			m.NewMaxMessageBodySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewMaxMessageBodySize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteTokenMessengerAdded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteTokenMessengerAdded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteTokenMessengerAdded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteTokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteTokenMessenger = append(m.RemoteTokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.RemoteTokenMessenger == nil {
				m.RemoteTokenMessenger = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteTokenMessengerRemoved) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteTokenMessengerRemoved: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteTokenMessengerRemoved: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteTokenMessenger", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteTokenMessenger = append(m.RemoteTokenMessenger[:0], dAtA[iNdEx:postIndex]...)
			if m.RemoteTokenMessenger == nil {
				m.RemoteTokenMessenger = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBurnLimitPerMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBurnLimitPerMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBurnLimitPerMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnLimitPerMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnLimitPerMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
